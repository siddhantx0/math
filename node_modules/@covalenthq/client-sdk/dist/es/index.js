import { parseISO } from 'date-fns';
import Big from 'big.js';

const DEFAULT_BACKOFF_MAX_RETRIES = 5;
const BASE_DELAY_MS = 1000; // Base delay in milliseconds
class ExponentialBackoff {
    constructor(apiKey, debug, maxRetries = DEFAULT_BACKOFF_MAX_RETRIES) {
        this.maxRetries = maxRetries;
        this.retryCount = 1;
        this._apiKey = apiKey;
        this._debug = debug;
    }
    async backOff(url, source) {
        try {
            let startTime;
            if (this._debug) {
                startTime = new Date();
            }
            const response = await fetch(url, {
                headers: {
                    "Authorization": `Bearer ${this._apiKey}`,
                    "X-Requested-With": source ? source + " " + "(" + userAgent + ")" : userAgent
                }
            });
            debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
            if (response.status === null || response.status === 429) {
                throw new Error(`Received status code: ${response.status ?? 429}`);
            }
            else {
                return response.json();
            }
        }
        catch (error) {
            if (error.message.includes(`Received status code: 429`) && this.retryCount < this.maxRetries) {
                this.retryCount++;
                const delayMs = Math.pow(2, this.retryCount) * BASE_DELAY_MS;
                await new Promise((resolve) => setTimeout(resolve, delayMs));
                return this.backOff(url, source);
            }
            return Promise.reject(new Error(`Max retries exceeded: ${this.maxRetries}`));
        }
    }
    // to reset the numAttempts for another request
    setNumAttempts(retryCount) {
        this.retryCount = retryCount;
    }
}

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

class Node {
	/// value;
	/// next;

	constructor(value) {
		this.value = value;

		// TODO: Remove this when targeting Node.js 12.
		this.next = undefined;
	}
}

let Queue$1 = class Queue {
	// TODO: Use private class fields when targeting Node.js 12.
	// #_head;
	// #_tail;
	// #_size;

	constructor() {
		this.clear();
	}

	enqueue(value) {
		const node = new Node(value);

		if (this._head) {
			this._tail.next = node;
			this._tail = node;
		} else {
			this._head = node;
			this._tail = node;
		}

		this._size++;
	}

	dequeue() {
		const current = this._head;
		if (!current) {
			return;
		}

		this._head = this._head.next;
		this._size--;
		return current.value;
	}

	clear() {
		this._head = undefined;
		this._tail = undefined;
		this._size = 0;
	}

	get size() {
		return this._size;
	}

	* [Symbol.iterator]() {
		let current = this._head;

		while (current) {
			yield current.value;
			current = current.next;
		}
	}
};

var yoctoQueue = Queue$1;

const Queue = yoctoQueue;

const pLimit = concurrency => {
	if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
		throw new TypeError('Expected `concurrency` to be a number from 1 and up');
	}

	const queue = new Queue();
	let activeCount = 0;

	const next = () => {
		activeCount--;

		if (queue.size > 0) {
			queue.dequeue()();
		}
	};

	const run = async (fn, resolve, ...args) => {
		activeCount++;

		const result = (async () => fn(...args))();

		resolve(result);

		try {
			await result;
		} catch {}

		next();
	};

	const enqueue = (fn, resolve, ...args) => {
		queue.enqueue(run.bind(null, fn, resolve, ...args));

		(async () => {
			// This function needs to wait until the next microtask before comparing
			// `activeCount` to `concurrency`, because `activeCount` is updated asynchronously
			// when the run function is dequeued and called. The comparison in the if-statement
			// needs to happen asynchronously as well to get an up-to-date value for `activeCount`.
			await Promise.resolve();

			if (activeCount < concurrency && queue.size > 0) {
				queue.dequeue()();
			}
		})();
	};

	const generator = (fn, ...args) => new Promise(resolve => {
		enqueue(fn, resolve, ...args);
	});

	Object.defineProperties(generator, {
		activeCount: {
			get: () => activeCount
		},
		pendingCount: {
			get: () => queue.size
		},
		clearQueue: {
			value: () => {
				queue.clear();
			}
		}
	});

	return generator;
};

var pLimit_1 = pLimit;

var pLimit$1 = /*@__PURE__*/getDefaultExportFromCjs(pLimit_1);

async function debugOutput(url, responseStatus, startTime) {
    let endTime;
    let elapsedTime;
    if (startTime === undefined) {
        return;
    }
    endTime = new Date();
    elapsedTime = endTime.getTime() - startTime.getTime();
    console.log("[DEBUG]" + " |" + " Request URL: " + url + " |" + " Response code: " + responseStatus + " |" + " Response time: " + elapsedTime.toFixed(2) + "ms");
}
async function* paginateEndpoint$1(url, apiKey, urlsParams, dataClassConstructor, debug, threadCount, enableRetry, source) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    let page_number = 0;
    const LIMIT = pLimit$1(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = new Date();
            }
            const link = urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`;
            response = await LIMIT(() => fetch(urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": source ? source + " " + "(" + userAgent + ")" : userAgent
                }
            }));
            debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
            if ((enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                try {
                    data = await LIMIT(() => backoff.backOff(response ? response.url : link, source));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response ? response.status : 429}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new dataClassConstructor(tx);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.pagination !== null && data.data.pagination.has_more === false) {
                    hasNext = false;
                }
                if (urlsParams.get("page-number")) {
                    const next_page = parseInt(urlsParams.get("page-number")) + 1;
                    urlsParams.set("page-number", next_page.toString());
                }
                else {
                    page_number = page_number + 1;
                }
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response ? response.status : "Unknown Error Code"}: ${data ? data.error_message : response && response.status === 500 ? "Internal server error" : "Unknown Error"}`);
        }
    }
}

class ApiKeyValidator {
    constructor(apiKey) {
        this._apiKey = apiKey;
    }
    isValidApiKey() {
        return ApiKeyValidator._apiKeyV1Pattern.test(this._apiKey) || ApiKeyValidator._apiKeyV2Pattern.test(this._apiKey);
    }
}
// Regular expression patterns
ApiKeyValidator._apiKeyV1Pattern = /^ckey_([a-f0-9]{27})$/;
ApiKeyValidator._apiKeyV2Pattern = /^cqt_(wF|rQ)([bcdfghjkmpqrtvwxyBCDFGHJKMPQRTVWXY346789]{26})$/;
ApiKeyValidator.INVALID_API_KEY_MESSAGE = "Invalid or missing API key (sign up at covalenthq.com/platform)";

class ApprovalsResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokensApprovalItem(itemData)) : null;
    }
}
class TokensApprovalItem {
    constructor(data) {
        this.token_address = data.token_address;
        this.token_address_label = data.token_address_label;
        this.ticker_symbol = data.ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_quote = data.balance_quote;
        this.pretty_balance_quote = data.pretty_balance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new TokenSpenderItem(itemData)) : null;
    }
}
class TokenSpenderItem {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.allowance = data.allowance;
        this.allowance_quote = data.allowance_quote;
        this.pretty_allowance_quote = data.pretty_allowance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.risk_factor = data.risk_factor;
    }
}
class NftApprovalsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftApprovalsItem(itemData)) : null;
    }
}
class NftApprovalsItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_address_label = data.contract_address_label;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.token_balances = data.token_balances && data.token_balances !== null ? data.token_balances.map((itemData) => new NftApprovalBalance(itemData)) : null;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new NftApprovalSpender(itemData)) : null;
    }
}
class NftApprovalBalance {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_balance = data.token_balance && data.token_balance !== null ? BigInt(data.token_balance) : null;
    }
}
class NftApprovalSpender {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.token_ids_approved = data.token_ids_approved;
        this.allowance = data.allowance;
    }
}
/**
 * Approvals API
 *
 */
class SecurityService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get a list of approvals across all token contracts categorized by spenders for a wallet’s assets.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ApprovalsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     
     *
     */
    async getNftApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/approvals/${walletAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftApprovalsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class BalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BalanceItem(itemData)) : null;
    }
}
class BalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.contract_display_name = data.contract_display_name;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h && data.balance_24h !== null ? BigInt(data.balance_24h) : null;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.quote = data.quote;
        this.quote_24h = data.quote_24h;
        this.pretty_quote = data.pretty_quote;
        this.pretty_quote_24h = data.pretty_quote_24h;
        this.logo_urls = data.logo_urls && data.logo_urls !== null ? new LogoUrls$1(data.logo_urls) : null;
        this.protocol_metadata = data.protocol_metadata && data.protocol_metadata !== null ? new ProtocolMetadata(data.protocol_metadata) : null;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new BalanceNftData(itemData)) : null;
    }
}
let LogoUrls$1 = class LogoUrls {
    constructor(data) {
        this.token_logo_url = data.token_logo_url;
        this.protocol_logo_url = data.protocol_logo_url;
        this.chain_logo_url = data.chain_logo_url;
    }
};
class ProtocolMetadata {
    constructor(data) {
        this.protocol_name = data.protocol_name;
    }
}
class BalanceNftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_balance = data.token_balance && data.token_balance !== null ? BigInt(data.token_balance) : null;
        this.token_url = data.token_url;
        this.supports_erc = data.supports_erc;
        this.token_price_wei = data.token_price_wei && data.token_price_wei !== null ? BigInt(data.token_price_wei) : null;
        this.token_quote_rate_eth = data.token_quote_rate_eth;
        this.original_owner = data.original_owner;
        this.owner = data.owner;
        this.owner_address = data.owner_address;
        this.burned = data.burned;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalDataV1(data.external_data) : null;
    }
}
class NftExternalDataV1 {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.owner = data.owner;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute$1(itemData)) : null;
    }
}
let NftCollectionAttribute$1 = class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
};
class PortfolioResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PortfolioItem(itemData)) : null;
    }
}
class PortfolioItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.holdings = data.holdings && data.holdings !== null ? data.holdings.map((itemData) => new HoldingItem(itemData)) : null;
    }
}
class HoldingItem {
    constructor(data) {
        this.quote_rate = data.quote_rate;
        this.timestamp = data.timestamp && data.timestamp !== null ? parseISO(data.timestamp.toString()) : null;
        this.close = data.close && data.close !== null ? new OhlcItem(data.close) : null;
        this.high = data.high && data.high !== null ? new OhlcItem(data.high) : null;
        this.low = data.low && data.low !== null ? new OhlcItem(data.low) : null;
        this.open = data.open && data.open !== null ? new OhlcItem(data.open) : null;
    }
}
class OhlcItem {
    constructor(data) {
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
    }
}
class Erc20TransfersResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BlockTransactionWithContractTransfers(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$3(data.pagination) : null;
    }
}
class BlockTransactionWithContractTransfers {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.miner_address = data.miner_address;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata$3(data.gas_metadata) : null;
        this.transfers = data.transfers && data.transfers !== null ? data.transfers.map((itemData) => new TokenTransferItem(itemData)) : null;
    }
}
let Pagination$3 = class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
};
let ContractMetadata$3 = class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
};
let Explorer$2 = class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
};
class TokenTransferItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.transfer_type = data.transfer_type;
        this.delta = data.delta && data.delta !== null ? BigInt(data.delta) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.delta_quote = data.delta_quote;
        this.pretty_delta_quote = data.pretty_delta_quote;
        this.balance_quote = data.balance_quote;
        this.method_calls = data.method_calls && data.method_calls !== null ? data.method_calls.map((itemData) => new MethodCallsForTransfers(itemData)) : null;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer$2(itemData)) : null;
    }
}
class MethodCallsForTransfers {
    constructor(data) {
        this.sender_address = data.sender_address;
        this.method = data.method;
    }
}
class TokenHoldersResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenHolder(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$3(data.pagination) : null;
    }
}
class TokenHolder {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.address = data.address;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.block_height = data.block_height;
    }
}
class HistoricalBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HistoricalBalanceItem(itemData)) : null;
    }
}
class HistoricalBalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.block_height = data.block_height;
        this.last_transferred_block_height = data.last_transferred_block_height;
        this.contract_display_name = data.contract_display_name;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.protocol_metadata = data.protocol_metadata && data.protocol_metadata !== null ? new ProtocolMetadata(data.protocol_metadata) : null;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new BalanceNftData(itemData)) : null;
    }
}
class TokenBalanceNativeResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NativeBalanceItem(itemData)) : null;
    }
}
class NativeBalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.block_height = data.block_height;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
    }
}
/**
 * Balances APIs
 *
 */
class BalanceService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address. Response includes spot prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *
     */
    async getTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render a daily portfolio balance for an address broken down by the token. The timeframe is user-configurable, defaults to 30 days.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalPortfolioForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `days`: The number of days to return data for. Defaults to 30 days.
     *
     */
    async getHistoricalPortfolioForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/portfolio_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/portfolio_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PortfolioResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getErc20TransfersForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.contractAddress !== undefined) {
                    urlParams.append("contract-address", queryParamOpts?.contractAddress.toString());
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/`, this.apiKey, urlParams, BlockTransactionWithContractTransfers, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getErc20TransfersForWalletAddressByPage(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.contractAddress !== undefined) {
                    urlParams.append("contract-address", queryParamOpts?.contractAddress.toString());
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new Erc20TransfersResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async *getTokenHoldersV2ForTokenAddress(chainName, tokenAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/`, this.apiKey, urlParams, TokenHolder, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getTokenHoldersV2ForTokenAddressByPage(chainName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TokenHoldersResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch the historical native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address at a given block height or date. Response includes daily prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getHistoricalTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/historical_balances/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/historical_balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HistoricalBalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNativeTokenBalanceQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *
     */
    async getNativeTokenBalance(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_native/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_native/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TokenBalanceNativeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class BlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Block(itemData)) : null;
    }
}
class Block {
    constructor(data) {
        this.block_hash = data.block_hash;
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
        this.block_parent_hash = data.block_parent_hash;
        this.extra_data = data.extra_data;
        this.miner_address = data.miner_address;
        this.mining_cost = data.mining_cost;
        this.gas_used = data.gas_used;
        this.gas_limit = data.gas_limit;
        this.transactions_link = data.transactions_link;
    }
}
class ResolvedAddress {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ResolvedAddressItem(itemData)) : null;
    }
}
class ResolvedAddressItem {
    constructor(data) {
        this.address = data.address;
        this.name = data.name;
    }
}
class BlockHeightsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BlockHeights(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$2(data.pagination) : null;
    }
}
class BlockHeights {
    constructor(data) {
        this.block_hash = data.block_hash;
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
        this.block_parent_hash = data.block_parent_hash;
        this.extra_data = data.extra_data;
        this.miner_address = data.miner_address;
        this.mining_cost = data.mining_cost;
        this.gas_used = data.gas_used;
        this.gas_limit = data.gas_limit;
        this.transactions_link = data.transactions_link;
    }
}
let Pagination$2 = class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
};
class GetLogsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new GetLogsEvent(itemData)) : null;
    }
}
class GetLogsEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.supports_erc = data.supports_erc;
        this.sender_logo_url = data.sender_logo_url;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$2(data.decoded) : null;
    }
}
let DecodedItem$2 = class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param$2(itemData)) : null;
    }
};
let Param$2 = class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
};
class LogEventsByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent$2(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$2(data.pagination) : null;
    }
}
let LogEvent$2 = class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$2(data.decoded) : null;
    }
};
class LogEventsByTopicHashResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent$2(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$2(data.pagination) : null;
    }
}
class AllChainsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainItem(itemData)) : null;
    }
}
class ChainItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.db_schema_name = data.db_schema_name;
        this.label = data.label;
        this.category_label = data.category_label;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.color_theme = data.color_theme && data.color_theme !== null ? new ColorTheme(data.color_theme) : null;
        this.appchain_of = data.appchain_of && data.appchain_of !== null ? new ChainItem(data.appchain_of) : null;
    }
}
class ColorTheme {
    constructor(data) {
        this.red = data.red;
        this.green = data.green;
        this.blue = data.blue;
        this.alpha = data.alpha;
        this.hex = data.hex;
        this.css_rgb = data.css_rgb;
    }
}
class AllChainsStatusResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainStatusItem(itemData)) : null;
    }
}
class ChainStatusItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.synced_block_height = data.synced_block_height;
        this.synced_blocked_signed_at = data.synced_blocked_signed_at && data.synced_blocked_signed_at !== null ? parseISO(data.synced_blocked_signed_at.toString()) : null;
        this.has_data = data.has_data;
    }
}
class ChainActivityResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainActivityEvent(itemData)) : null;
    }
}
class ChainActivityEvent extends ChainItem {
    constructor(data) {
        super(data);
        this.last_seen_at = data.last_seen_at && data.last_seen_at !== null ? parseISO(data.last_seen_at.toString()) : null;
    }
}
class GasPricesResponse {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.event_type = data.event_type;
        this.gas_quote_rate = data.gas_quote_rate;
        this.base_fee = data.base_fee && data.base_fee !== null ? BigInt(data.base_fee) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PriceItem(itemData)) : null;
    }
}
class PriceItem {
    constructor(data) {
        this.gas_price = data.gas_price;
        this.gas_spent = data.gas_spent;
        this.gas_quote = data.gas_quote;
        this.total_gas_quote = data.total_gas_quote;
        this.pretty_total_gas_quote = data.pretty_total_gas_quote;
        this.interval = data.interval;
        this.other_fees = data.other_fees && data.other_fees !== null ? new OtherFees(data.other_fees) : null;
    }
}
class OtherFees {
    constructor(data) {
        this.l1_gas_quote = data.l1_gas_quote;
    }
}
/**
 * Class A - Base
 *
 */
class BaseService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single block for a block explorer.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHeight - The block height or `latest` for the latest block available.
     *
     */
    async getBlock(chainName, blockHeight) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to resolve ENS, RNS and Unstoppable Domains addresses.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getResolvedAddress(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ResolvedAddress(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getBlockHeights(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/`, this.apiKey, urlParams, Block, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getBlockHeightsByPage(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockHeightsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs of the latest block, or for a range of blocks. Includes sender contract metadata as well as decoded logs.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetLogsQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `address`: The address of the log events sender contract.
     *   - `topics`: The topic hash(es) to retrieve logs with.
     *   - `blockHash`: The block hash to retrieve logs for.
     *   - `skipDecode`: Omit decoded log events.
     *
     */
    async getLogs(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.address !== undefined) {
                    urlParams.append("address", queryParamOpts?.address.toString());
                }
                if (queryParamOpts?.topics !== undefined) {
                    urlParams.append("topics", queryParamOpts?.topics.toString());
                }
                if (queryParamOpts?.blockHash !== undefined) {
                    urlParams.append("block-hash", queryParamOpts?.blockHash.toString());
                }
                if (queryParamOpts?.skipDecode !== undefined) {
                    urlParams.append("skip-decode", queryParamOpts?.skipDecode.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GetLogsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByAddress(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/`, this.apiKey, urlParams, LogEvent$2, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByAddressByPage(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new LogEventsByAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByTopicHash(chainName, topicHash, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/`, this.apiKey, urlParams, LogEvent$2, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByTopicHashByPage(chainName, topicHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new LogEventsByTopicHashResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal dashboards for all supported chains on Covalent.
     *
     *
     */
    async getAllChains() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/chains/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal status dashboards of all supported chains.
     *
     *
     */
    async getAllChainStatus() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/chains/status/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/status/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsStatusResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to locate chains which an address is active on with a single API call.
     *
     * @param {string} walletAddress - The requested wallet address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAddressActivityQueryParamOpts} queryParamOpts
     *   - `testnets`: Set to true to include testnets with activity in the response. By default, it's set to `false` and only returns mainnet activity.
     *
     */
    async getAddressActivity(walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.testnets !== undefined) {
                    urlParams.append("testnets", queryParamOpts?.testnets.toString());
                }
                const url = `https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainActivityResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} eventType - The desired event type to retrieve gas prices for. Supports `erc20` transfer events, `uniswapv3` swap events and `nativetokens` transfers.
     * @param {GetGasPricesQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getGasPrices(chainName, eventType, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/event/${eventType}/gas_prices/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/event/${eventType}/gas_prices/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GasPricesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class ChainCollectionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainCollectionItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$1(data.pagination) : null;
    }
}
class ChainCollectionItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.is_spam = data.is_spam;
        this.token_total_supply = data.token_total_supply;
        this.cached_metadata_count = data.cached_metadata_count;
        this.cached_asset_count = data.cached_asset_count;
        this.last_scraped_at = data.last_scraped_at && data.last_scraped_at !== null ? parseISO(data.last_scraped_at.toString()) : null;
    }
}
let Pagination$1 = class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
};
class NftAddressBalanceNftResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContractBalanceItem(itemData)) : null;
    }
}
class NftTokenContractBalanceItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.floor_price_quote = data.floor_price_quote;
        this.pretty_floor_price_quote = data.pretty_floor_price_quote;
        this.floor_price_native_quote = data.floor_price_native_quote;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new NftData(itemData)) : null;
    }
}
class NftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_url = data.token_url;
        this.original_owner = data.original_owner;
        this.current_owner = data.current_owner;
        this.asset_cached = data.asset_cached;
        this.image_cached = data.image_cached;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalData(data.external_data) : null;
    }
}
class NftExternalData {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.asset_url = data.asset_url;
        this.asset_file_extension = data.asset_file_extension;
        this.asset_mime_type = data.asset_mime_type;
        this.asset_size_bytes = data.asset_size_bytes;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute(itemData)) : null;
    }
}
class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
}
class NftMetadataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContract(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination$1(data.pagination) : null;
    }
}
class NftTokenContract {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.is_spam = data.is_spam;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
class NftTransactionsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTransaction(itemData)) : null;
    }
}
class NftTransaction {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.nft_transactions = data.nft_transactions && data.nft_transactions !== null ? data.nft_transactions.map((itemData) => new NftTransactionItem(itemData)) : null;
    }
}
class NftTransactionItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent$1(itemData)) : null;
    }
}
let LogEvent$1 = class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem$1(data.decoded) : null;
    }
};
let DecodedItem$1 = class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param$1(itemData)) : null;
    }
};
let Param$1 = class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
};
class NftCollectionTraitsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTrait(itemData)) : null;
    }
}
class NftTrait {
    constructor(data) {
        this.name = data.name;
    }
}
class NftCollectionAttributesForTraitResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftSummaryAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.unique_values = data.unique_values;
        this.values = data.values && data.values !== null ? data.values.map((itemData) => new NftAttribute(itemData)) : null;
    }
}
class NftAttribute {
    constructor(data) {
        this.value = data.value;
        this.count = data.count;
    }
}
class NftCollectionTraitSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTraitSummary(itemData)) : null;
    }
}
class NftTraitSummary {
    constructor(data) {
        this.name = data.name;
        this.value_type = data.value_type;
        this.value_numeric = data.value_numeric && data.value_numeric !== null ? new NftTraitNumeric(data.value_numeric) : null;
        this.value_string = data.value_string && data.value_string !== null ? new NftTraitString(data.value_string) : null;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftTraitNumeric {
    constructor(data) {
        this.min = data.min;
        this.max = data.max;
    }
}
class NftTraitString {
    constructor(data) {
        this.value = data.value;
        this.token_count = data.token_count;
        this.trait_percentage = data.trait_percentage;
    }
}
class NftOwnershipForCollectionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.collection = data.collection;
        this.is_spam = data.is_spam;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftOwnershipForCollectionItem(itemData)) : null;
    }
}
class NftOwnershipForCollectionItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.supports_erc = data.supports_erc;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
class NftMarketSaleCountResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketSaleCountItem(itemData)) : null;
    }
}
class MarketSaleCountItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.sale_count = data.sale_count;
    }
}
class NftMarketVolumeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketVolumeItem(itemData)) : null;
    }
}
class MarketVolumeItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.native_ticker_symbol = data.native_ticker_symbol;
        this.native_name = data.native_name;
        this.volume_quote = data.volume_quote;
        this.volume_native_quote = data.volume_native_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
    }
}
class NftMarketFloorPriceResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketFloorPriceItem(itemData)) : null;
    }
}
class MarketFloorPriceItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.native_ticker_symbol = data.native_ticker_symbol;
        this.native_name = data.native_name;
        this.floor_price_native_quote = data.floor_price_native_quote;
        this.floor_price_quote = data.floor_price_quote;
        this.pretty_floor_price_quote = data.pretty_floor_price_quote;
    }
}
/**
 * NFT APIs
 *
 */
class NftService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async *getChainCollections(chainName, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/nft/collections/`, this.apiKey, urlParams, ChainCollectionItem, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getChainCollectionsByPage(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/collections/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/collections/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render the NFTs (including ERC721 and ERC1155) held by an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftsForAddressQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_nft/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_nft/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftAddressBalanceNftResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async *getTokenIdsForContractWithMetadata(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                for await (res of paginateEndpoint$1(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/`, this.apiKey, urlParams, NftTokenContract, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getTokenIdsForContractWithMetadataByPage(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMetadataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a single NFT metadata by token ID from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftMetadataForGivenTokenIdForContractQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftMetadataForGivenTokenIdForContract(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMetadataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all transactions of an NFT token. Useful for building a transaction history table or price chart.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftTransactionsForContractTokenIdQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getNftTransactionsForContractTokenId(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftTransactionsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the traits of a collection as seen in rarity calculators.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTraitsForCollection(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the count of unique values for traits within an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} trait - The requested trait.
     *
     */
    async getAttributesForTraitInCollection(chainName, collectionContract, trait) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/${trait}/attributes/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/${trait}/attributes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionAttributesForTraitResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to calculate rarity scores for a collection based on its traits.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getCollectionTraitsSummary(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits_summary/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitSummaryResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of NFTs (including ERC-721 and ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address.
     * @param {CheckOwnershipInNftQueryParamOpts} queryParamOpts
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Must be used with "values-filter", is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. Must be used with "traits-filter", is case-sensitive, and requires proper URL encoding.
     *
     */
    async checkOwnershipInNft(chainName, walletAddress, collectionContract, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of a specific token (ERC-721 or ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     *
     */
    async checkOwnershipInNftForSpecificTokenId(chainName, walletAddress, collectionContract, tokenId) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build a time-series chart of the sales count of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketSaleCountQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketSaleCount(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/sale_count/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/sale_count/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketSaleCountResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build a time-series chart of the transaction volume of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketVolumeQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketVolume(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/volume/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/volume/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketVolumeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render a price floor chart for an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketFloorPriceQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketFloorPrice(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/floor_price/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/floor_price/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketFloorPriceResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class TokenPricesResponse {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.update_at = data.update_at && data.update_at !== null ? parseISO(data.update_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.logo_urls = data.logo_urls && data.logo_urls !== null ? new LogoUrls(data.logo_urls) : null;
        this.prices = data.prices && data.prices !== null ? data.prices.map((itemData) => new Price(itemData)) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Price(itemData)) : null;
    }
}
class LogoUrls {
    constructor(data) {
        this.token_logo_url = data.token_logo_url;
        this.protocol_logo_url = data.protocol_logo_url;
        this.chain_logo_url = data.chain_logo_url;
    }
}
class Price {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.price = data.price;
        this.pretty_price = data.pretty_price;
        this.contract_metadata = data.contract_metadata && data.contract_metadata !== null ? new ContractMetadata$2(data.contract_metadata) : null;
    }
}
let ContractMetadata$2 = class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
};
/**
 * Pricing APIs
 *
 */
let Response$1 = class Response {
};
class PricingService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get historic prices of a token between date ranges. Supports native tokens.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} quoteCurrency - The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     * @param {string} contractAddress - Contract address for the token. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically. Supports multiple contract addresses separated by commas.
     * @param {GetTokenPricesQueryParamOpts} queryParamOpts
     *   - `from`: The start day of the historical price range (YYYY-MM-DD).
     *   - `to`: The end day of the historical price range (YYYY-MM-DD).
     *   - `pricesAtAsc`: Sort the prices in chronological ascending order. By default, it's set to `false` and returns prices in chronological descending order.
     *
     */
    async getTokenPrices(chainName, quoteCurrency, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.from !== undefined) {
                    urlParams.append("from", queryParamOpts?.from.toString());
                }
                if (queryParamOpts?.to !== undefined) {
                    urlParams.append("to", queryParamOpts?.to.toString());
                }
                if (queryParamOpts?.pricesAtAsc !== undefined) {
                    urlParams.append("prices-at-asc", queryParamOpts?.pricesAtAsc.toString());
                }
                const url = `https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const res = [];
                data.data.forEach((e) => {
                    const dataClass = new TokenPricesResponse(e);
                    res.push(dataClass);
                });
                success = true;
                return {
                    data: res,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class TransactionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class Transaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.miner_address = data.miner_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata$1(data.gas_metadata) : null;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer$1(itemData)) : null;
        this.dex_details = data.dex_details && data.dex_details !== null ? data.dex_details.map((itemData) => new DexReport(itemData)) : null;
        this.nft_sale_details = data.nft_sale_details && data.nft_sale_details !== null ? data.nft_sale_details.map((itemData) => new NftSalesReport(itemData)) : null;
        this.lending_details = data.lending_details && data.lending_details !== null ? data.lending_details.map((itemData) => new LendingReport(itemData)) : null;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent(itemData)) : null;
        this.safe_details = data.safe_details && data.safe_details !== null ? data.safe_details.map((itemData) => new SafeDetails(itemData)) : null;
    }
}
let ContractMetadata$1 = class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
};
let Explorer$1 = class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
};
class DexReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.aggregator_name = data.aggregator_name;
        this.aggregator_address = data.aggregator_address;
        this.version = data.version;
        this.fork_version = data.fork_version;
        this.fork = data.fork;
        this.event = data.event;
        this.pair_address = data.pair_address;
        this.pair_lp_fee_bps = data.pair_lp_fee_bps;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_ticker = data.lp_token_ticker;
        this.lp_token_num_decimals = data.lp_token_num_decimals;
        this.lp_token_name = data.lp_token_name;
        this.lp_token_value = data.lp_token_value;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_0_address = data.token_0_address;
        this.token_0_ticker = data.token_0_ticker;
        this.token_0_num_decimals = data.token_0_num_decimals;
        this.token_0_name = data.token_0_name;
        this.token_1_address = data.token_1_address;
        this.token_1_ticker = data.token_1_ticker;
        this.token_1_num_decimals = data.token_1_num_decimals;
        this.token_1_name = data.token_1_name;
        this.token_0_amount = data.token_0_amount;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_0_usd_quote = data.token_0_usd_quote;
        this.pretty_token_0_usd_quote = data.pretty_token_0_usd_quote;
        this.token_0_logo_url = data.token_0_logo_url;
        this.token_1_amount = data.token_1_amount;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.token_1_usd_quote = data.token_1_usd_quote;
        this.pretty_token_1_usd_quote = data.pretty_token_1_usd_quote;
        this.token_1_logo_url = data.token_1_logo_url;
        this.sender = data.sender;
        this.recipient = data.recipient;
    }
}
class NftSalesReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.topic0 = data.topic0;
        this.protocol_contract_address = data.protocol_contract_address;
        this.protocol_name = data.protocol_name;
        this.protocol_logo_url = data.protocol_logo_url;
        this.to = data.to;
        this.from = data.from;
        this.maker = data.maker;
        this.taker = data.taker;
        this.token_id = data.token_id;
        this.collection_address = data.collection_address;
        this.collection_name = data.collection_name;
        this.token_address = data.token_address;
        this.token_name = data.token_name;
        this.ticker_symbol = data.ticker_symbol;
        this.num_decimals = data.num_decimals;
        this.contract_quote_rate = data.contract_quote_rate;
        this.nft_token_price = data.nft_token_price;
        this.nft_token_price_usd = data.nft_token_price_usd;
        this.pretty_nft_token_price_usd = data.pretty_nft_token_price_usd;
        this.nft_token_price_native = data.nft_token_price_native;
        this.pretty_nft_token_price_native = data.pretty_nft_token_price_native;
        this.token_count = data.token_count;
        this.num_token_ids_sold_per_sale = data.num_token_ids_sold_per_sale;
        this.num_token_ids_sold_per_tx = data.num_token_ids_sold_per_tx;
        this.num_collections_sold_per_sale = data.num_collections_sold_per_sale;
        this.num_collections_sold_per_tx = data.num_collections_sold_per_tx;
        this.trade_type = data.trade_type;
        this.trade_group_type = data.trade_group_type;
    }
}
class LendingReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.version = data.version;
        this.fork = data.fork;
        this.fork_version = data.fork_version;
        this.event = data.event;
        this.lp_token_name = data.lp_token_name;
        this.lp_decimals = data.lp_decimals;
        this.lp_ticker_symbol = data.lp_ticker_symbol;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_amount = data.lp_token_amount;
        this.lp_token_price = data.lp_token_price;
        this.exchange_rate = data.exchange_rate;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_name_in = data.token_name_in;
        this.token_decimal_in = data.token_decimal_in;
        this.token_address_in = data.token_address_in;
        this.token_ticker_in = data.token_ticker_in;
        this.token_logo_in = data.token_logo_in;
        this.token_amount_in = data.token_amount_in;
        this.amount_in_usd = data.amount_in_usd;
        this.pretty_amount_in_usd = data.pretty_amount_in_usd;
        this.token_name_out = data.token_name_out;
        this.token_decimals_out = data.token_decimals_out;
        this.token_address_out = data.token_address_out;
        this.token_ticker_out = data.token_ticker_out;
        this.token_logo_out = data.token_logo_out;
        this.token_amount_out = data.token_amount_out;
        this.amount_out_usd = data.amount_out_usd;
        this.pretty_amount_out_usd = data.pretty_amount_out_usd;
        this.borrow_rate_mode = data.borrow_rate_mode;
        this.borrow_rate = data.borrow_rate;
        this.on_behalf_of = data.on_behalf_of;
        this.liquidator = data.liquidator;
        this.user = data.user;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class SafeDetails {
    constructor(data) {
        this.owner_address = data.owner_address;
        this.signature = data.signature;
        this.signature_type = data.signature_type;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class RecentTransactionsResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.current_page = data.current_page;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class PaginationLinks {
    constructor(data) {
        this.prev = data.prev;
        this.next = data.next;
    }
}
class TransactionsBlockPageResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class TransactionsBlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class TransactionsSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TransactionsSummary(itemData)) : null;
    }
}
class GasSummary {
    constructor(data) {
        this.total_sent_count = data.total_sent_count;
        this.total_fees_paid = data.total_fees_paid && data.total_fees_paid !== null ? BigInt(data.total_fees_paid) : null;
        this.total_gas_quote = data.total_gas_quote;
        this.pretty_total_gas_quote = data.pretty_total_gas_quote;
        this.average_gas_quote_per_tx = data.average_gas_quote_per_tx;
        this.pretty_average_gas_quote_per_tx = data.pretty_average_gas_quote_per_tx;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata$1(data.gas_metadata) : null;
    }
}
class TransactionsSummary {
    constructor(data) {
        this.total_count = data.total_count;
        this.earliest_transaction = data.earliest_transaction && data.earliest_transaction !== null ? new TransactionSummary(data.earliest_transaction) : null;
        this.latest_transaction = data.latest_transaction && data.latest_transaction !== null ? new TransactionSummary(data.latest_transaction) : null;
        this.gas_summary = data.gas_summary && data.gas_summary !== null ? new GasSummary(data.gas_summary) : null;
    }
}
class TransactionSummary {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.tx_detail_link = data.tx_detail_link;
    }
}
class TransactionsResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.current_page = data.current_page;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class TransactionsTimeBucketResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.complete = data.complete;
        this.current_bucket = data.current_bucket;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit$1(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
/**
 * Transactions APIs
 *
 */
async function* paginateEndpoint(url, apiKey, urlsParams, debug, threadCount, enableRetry, source) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    const LIMIT = pLimit$1(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = new Date();
            }
            response = await LIMIT(() => fetch(`${url}?${urlsParams}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": source ? source + " " + "(" + userAgent + ")" : userAgent
                }
            }));
            debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
            if ((enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                try {
                    data = await LIMIT(() => backoff.backOff(response ? response.url : `${url}?${urlsParams}`, this.source));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response ? response.status : 429}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new Transaction(tx);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.links.prev === null) {
                    hasNext = false;
                }
                url = data.data !== null ? data.data.links.prev : "";
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response ? response.status : "Unknown Error Code"}: ${data ? data.error_message : response && response.status === 500 ? "Internal server error" : "Unknown Error"}`);
        }
    }
}
class TransactionService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single transaction including its decoded log events. Additionally return semantically decoded information for DEX trades, lending and NFT sales.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} txHash - The transaction hash.
     * @param {GetTransactionQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withDex`: Decoded DEX details including protocol (e.g. Uniswap), event (e.g 'add_liquidity') and tokens involved with historical prices. Additional 0.05 credits charged if data available.
     *   - `withNftSales`: Decoded NFT sales details including marketplace (e.g. Opensea) and cached media links. Additional 0.05 credits charged if data available.
     *   - `withLending`: Decoded lending details including protocol (e.g. Aave), event (e.g. 'deposit') and tokens involved with prices. Additional 0.05 credits charged if data available.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransaction(chainName, txHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withDex !== undefined) {
                    urlParams.append("with-dex", queryParamOpts?.withDex.toString());
                }
                if (queryParamOpts?.withNftSales !== undefined) {
                    urlParams.append("with-nft-sales", queryParamOpts?.withNftSales.toString());
                }
                if (queryParamOpts?.withLending !== undefined) {
                    urlParams.append("with-lending", queryParamOpts?.withLending.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/transaction_v2/${txHash}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/transaction_v2/${txHash}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async *getAllTransactionsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let tx;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                for await (tx of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/`, this.apiKey, urlParams, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield tx;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getAllTransactionsForAddressByPage(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {number} blockHeight - The requested block height.
     * @param {GetTransactionsForBlockQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlock(chainName, blockHeight, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block/${blockHeight}/transactions_v3/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block/${blockHeight}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch the earliest and latest transactions, and the transaction count for a wallet. Calculate the age of the wallet and the time it has been idle and quickly gain insights into their engagement with web3.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionSummaryQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `withGas`: Include gas summary details. Additional charge of 1 credit when true. Response times may be impacted for wallets with millions of transactions.
     *
     */
    async getTransactionSummary(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.withGas !== undefined) {
                    urlParams.append("with-gas", queryParamOpts?.withGas.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_summary/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsSummaryResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested page, 0-indexed.
     * @param {GetTransactionsForAddressV3QueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForAddressV3(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/page/${page}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} timeBucket - The 0-indexed 15-minute time bucket. E.g. 27 Feb 2023 05:23 GMT = 1677475383 (Unix time). 1677475383/900=1863861 timeBucket.
     * @param {GetTimeBucketTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTimeBucketTransactionsForAddress(chainName, walletAddress, timeBucket, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/bulk/transactions/${walletAddress}/${timeBucket}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/bulk/transactions/${walletAddress}/${timeBucket}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHash - The requested block hash.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetTransactionsForBlockHashByPageQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHashByPage(chainName, blockHash, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHash - The requested block hash.
     * @param {GetTransactionsForBlockHashQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHash(chainName, blockHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

class PoolResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Pool(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class Pool {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
}
class Token {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.volume_in_24h = data.volume_in_24h;
        this.volume_out_24h = data.volume_out_24h;
        this.quote_rate = data.quote_rate;
        this.reserve = data.reserve;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.volume_in_7d = data.volume_in_7d;
        this.volume_out_7d = data.volume_out_7d;
    }
}
class PoolToDexResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolToDexItem(itemData)) : null;
    }
}
class SupportedDex {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.dex_name = data.dex_name;
        this.display_name = data.display_name;
        this.logo_url = data.logo_url;
        this.factory_contract_address = data.factory_contract_address;
        this.router_contract_addresses = data.router_contract_addresses;
        this.swap_fee = data.swap_fee;
    }
}
class PoolToDexItem extends SupportedDex {
    constructor(data) {
        super(data);
        this.logo_url = data.logo_url;
    }
}
class PoolByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolWithTimeseries {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.token_0_reserve_quote = data.token_0_reserve_quote;
        this.token_1_reserve_quote = data.token_1_reserve_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTimeseries(itemData)) : null;
    }
}
class VolumeTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.sum_amount0in = data.sum_amount0in;
        this.sum_amount0out = data.sum_amount0out;
        this.sum_amount1in = data.sum_amount1in;
        this.sum_amount1out = data.sum_amount1out;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.r0_c = data.r0_c;
        this.r1_c = data.r1_c;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
    }
}
class PriceTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.price_of_token0_in_token1 = data.price_of_token0_in_token1;
        this.pretty_price_of_token0_in_token1 = data.pretty_price_of_token0_in_token1;
        this.price_of_token0_in_token1_description = data.price_of_token0_in_token1_description;
        this.price_of_token1_in_token0 = data.price_of_token1_in_token0;
        this.pretty_price_of_token1_in_token0 = data.pretty_price_of_token1_in_token0;
        this.price_of_token1_in_token0_description = data.price_of_token1_in_token0_description;
        this.quote_currency = data.quote_currency;
        this.price_of_token0_in_quote_currency = data.price_of_token0_in_quote_currency;
        this.price_of_token1_in_quote_currency = data.price_of_token1_in_quote_currency;
    }
}
class PoolsDexDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolsDexDataItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolsDexDataItem {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.exchange = data.exchange;
        this.exchange_ticker_symbol = data.exchange_ticker_symbol;
        this.exchange_logo_url = data.exchange_logo_url;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.volume_7d_quote = data.volume_7d_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.quote_rate = data.quote_rate;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.annualized_fee = data.annualized_fee;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolsDexToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolsDexToken(data.token_1) : null;
    }
}
class PoolsDexToken {
    constructor(data) {
        this.reserve = data.reserve;
        this.contract_name = data.contract_name;
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
    }
}
class AddressExchangeBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeBalanceItem(itemData)) : null;
    }
}
class UniswapLikeBalanceItem {
    constructor(data) {
        this.token_0 = data.token_0 && data.token_0 !== null ? new UniswapLikeToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new UniswapLikeToken(data.token_1) : null;
        this.pool_token = data.pool_token && data.pool_token !== null ? new UniswapLikeTokenWithSupply(data.pool_token) : null;
    }
}
class UniswapLikeToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.quote_rate = data.quote_rate;
    }
}
class UniswapLikeTokenWithSupply {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.quote_rate = data.quote_rate;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
    }
}
class NetworkExchangeTokensResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2Volume(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2Volume {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume_24h = data.total_volume_24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.pretty_quote_rate_24h = data.pretty_quote_rate_24h;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_total_volume_24h_quote = data.pretty_total_volume_24h_quote;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
    }
}
class NetworkExchangeTokenViewResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2VolumeWithChartData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2VolumeWithChartData {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume_24h = data.total_volume_24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.pretty_quote_rate_24h = data.pretty_quote_rate_24h;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_total_volume_24h_quote = data.pretty_total_volume_24h_quote;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
        this.transactions_24h = data.transactions_24h;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTokenTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTokenTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTokenTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTokenTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTokenTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTokenTimeseries(itemData)) : null;
    }
}
class VolumeTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.total_volume = data.total_volume;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
    }
}
class LiquidityTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.total_liquidity = data.total_liquidity;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
    }
}
class PriceTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.quote_rate = data.quote_rate;
        this.pretty_quote_rate = data.pretty_quote_rate;
    }
}
class SupportedDexesResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new SupportedDex(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class SingleNetworkExchangeTokenResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForAccountAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class ExchangeTransaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.act = data.act;
        this.address = data.address;
        this.amount_0 = data.amount_0;
        this.amount_1 = data.amount_1;
        this.amount_0_in = data.amount_0_in;
        this.amount_0_out = data.amount_0_out;
        this.amount_1_in = data.amount_1_in;
        this.amount_1_out = data.amount_1_out;
        this.to_address = data.to_address;
        this.from_address = data.from_address;
        this.sender_address = data.sender_address;
        this.total_quote = data.total_quote;
        this.pretty_total_quote = data.pretty_total_quote;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.quote_currency = data.quote_currency;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolToken(data.token_1) : null;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class PoolToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class TransactionsForTokenAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForExchangeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class NetworkTransactionsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class EcosystemChartDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeEcosystemCharts(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class UniswapLikeEcosystemCharts {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.quote_currency = data.quote_currency;
        this.gas_token_price_quote = data.gas_token_price_quote;
        this.total_swaps_24h = data.total_swaps_24h;
        this.total_active_pairs_7d = data.total_active_pairs_7d;
        this.total_fees_24h = data.total_fees_24h;
        this.pretty_gas_token_price_quote = data.pretty_gas_token_price_quote;
        this.pretty_total_fees_24h = data.pretty_total_fees_24h;
        this.volume_chart_7d = data.volume_chart_7d && data.volume_chart_7d !== null ? data.volume_chart_7d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.volume_chart_30d = data.volume_chart_30d && data.volume_chart_30d !== null ? data.volume_chart_30d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.liquidity_chart_7d = data.liquidity_chart_7d && data.liquidity_chart_7d !== null ? data.liquidity_chart_7d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
        this.liquidity_chart_30d = data.liquidity_chart_30d && data.liquidity_chart_30d !== null ? data.liquidity_chart_30d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
    }
}
class VolumeEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
    }
}
class HealthDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HealthData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class HealthData {
    constructor(data) {
        this.synced_block_height = data.synced_block_height;
        this.synced_block_signed_at = data.synced_block_signed_at && data.synced_block_signed_at !== null ? parseISO(data.synced_block_signed_at.toString()) : null;
        this.latest_block_height = data.latest_block_height;
        this.latest_block_signed_at = data.latest_block_signed_at && data.latest_block_signed_at !== null ? parseISO(data.latest_block_signed_at.toString()) : null;
    }
}
/**
 * XYK APIs
 *
 */
class XykService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit$1(this.threadCount);
    }
    /**
     *
     * Commonly used to get all the pools of a particular DEX. Supports most common DEXs (Uniswap, SushiSwap, etc), and returns detailed trading data (volume, liquidity, swap counts, fees, LP token prices).
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetPoolsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getPools(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the corresponding supported DEX given a pool address, along with the swap fees, DEX's logo url, and factory addresses. Useful to identifying the specific DEX to which a pair address is associated.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} poolAddress - The requested pool address.
     *
     */
    async getDexForPoolAddress(chainName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolToDexResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the 7 day and 30 day time-series data (volume, liquidity, price) of a particular liquidity pool in a DEX. Useful for building time-series charts on DEX trading activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getPoolByAddress(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolByAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and the supported DEX for a token. Useful for building a table of top pairs across all supported DEXes that the token is trading on.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `dexName`: The DEX name eg: `uniswap_v2`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *
     */
    async getPoolsForTokenAddress(chainName, tokenAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.dexName !== undefined) {
                    urlParams.append("dex-name", queryParamOpts?.dexName.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to return balance of a wallet/contract address on a specific DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address.
     *
     */
    async getAddressExchangeBalances(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AddressExchangeBalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and supported DEX for a wallet. Useful for building a personal DEX UI showcasing pairs and supported DEXes associated to the wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The account address.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForWalletAddressQueryParamOpts} queryParamOpts
     *   - `tokenAddress`: The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `dexName`: The DEX name eg: `uniswap_v2`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *
     */
    async getPoolsForWalletAddress(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.tokenAddress !== undefined) {
                    urlParams.append("token-address", queryParamOpts?.tokenAddress.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.dexName !== undefined) {
                    urlParams.append("dex-name", queryParamOpts?.dexName.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to retrieve all network exchange tokens for a specific DEX. Useful for building a top tokens table by total liquidity within a particular DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetNetworkExchangeTokensQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getNetworkExchangeTokens(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokensResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a detailed view for a single liquidity pool token. Includes time series data.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLpTokenViewQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getLpTokenView(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/view/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/view/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokenViewResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the supported DEXs available for the xy=k endpoints, along with the swap fees and factory addresses.
     *
     *
     */
    async getSupportedDEXes() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SupportedDexesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get historical daily swap count for a single network exchange token.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetSingleNetworkExchangeTokenQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getSingleNetworkExchangeToken(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SingleNetworkExchangeTokenResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the DEX transactions of a wallet. Useful for building tables of DEX activity segmented by wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address. Passing in an `ENS` or `RNS` resolves automatically.
     *
     */
    async getTransactionsForAccountAddress(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForAccountAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the transactions of a token within a particular DEX. Useful for getting a per-token view of DEX activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForTokenAddress(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForTokenAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used for getting all the transactions of a particular DEX liquidity pool. Useful for building a transactions history table for an individual pool.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionsForExchangeQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForExchange(chainName, dexName, poolAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForExchangeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the the transactions for a given DEX. Useful for building DEX activity views.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetTransactionsForDexQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForDex(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkTransactionsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a 7d and 30d time-series chart of DEX activity. Includes volume and swap count.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getEcosystemChartData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new EcosystemChartDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to ping the health of xy=k endpoints to get the synced block height per chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getHealthData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HealthDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}

const userAgent = "com.covalenthq.sdk.typescript/1.0.2";
class Response {
}
/**
 * CovalentClient Class
 */
class CovalentClient {
    constructor(apiKey, settings, source) {
        const { debug = false, threadCount = 3, enableRetry = true } = settings || {};
        const validator = new ApiKeyValidator(apiKey);
        this._is_key_valid = validator.isValidApiKey();
        this.SecurityService = new SecurityService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.BalanceService = new BalanceService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.BaseService = new BaseService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.NftService = new NftService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.PricingService = new PricingService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.TransactionService = new TransactionService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.XykService = new XykService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
    }
}
/**
 * @deprecated
 * Please use {@link CovalentClient} going forward! This method will be removed after Oct 31, 2023.
 * @see #CovalentClient
 * CovalentClient Class
 */
class Client {
    constructor(apiKey, settings, source) {
        const { debug = false, threadCount = 3, enableRetry = true } = settings || {};
        const validator = new ApiKeyValidator(apiKey);
        this._is_key_valid = validator.isValidApiKey();
        this.SecurityService = new SecurityService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.BalanceService = new BalanceService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.BaseService = new BaseService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.NftService = new NftService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.PricingService = new PricingService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.TransactionService = new TransactionService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
        this.XykService = new XykService(apiKey, debug, threadCount, this._is_key_valid, enableRetry, source);
    }
}

const calculatePrettyBalance = (value, decimals = 18, roundOff = true, precision = 0) => {
    let bigIntValue;
    let bigDecimalValue;
    try {
        bigIntValue = BigInt(value);
        bigDecimalValue = new Big(bigIntValue.toString());
    }
    catch (error) {
        bigDecimalValue = new Big(value.toString());
    }
    const _decimals = decimals ?? 18;
    const _expoValue = BigInt(Math.pow(10, _decimals));
    const bigDecimalExpo = new Big(_expoValue.toString());
    const _calculated = bigDecimalValue.div(bigDecimalExpo);
    if (decimals === 0) {
        return _calculated.toString();
    }
    // removes the decimal places, true by default so it adds decimals
    if (!roundOff) {
        return _calculated.toString();
    }
    let _decimalFixed = precision;
    if (precision === 0) {
        _decimalFixed = 2;
        if (_calculated.lt(100)) {
            _decimalFixed = 6;
        }
    }
    return _calculated.toFixed(_decimalFixed);
};

const LESS_THAN_ZERO = "0.01";
const ZERO = "0.00";
const currencyMap = new Map([
    ["USD", "$"],
    ["CAD", "CA$"],
    ["EUR", "€"],
    ["SGD", "S$"],
    ["INR", "₹"],
    ["JPY", "¥"],
    ["VND", "₫"],
    ["CNY", "CN¥"],
    ["KRW", "₩"],
    ["RUB", "₽"],
    ["TRY", "₺"],
    ["NGN", "₦"],
    ["ARS", "ARS"],
    ["AUD", "A$"],
    ["CHF", "CHF"],
    ["GBP", "£"],
]);
const prettifyCurrency = (value, decimals = 2, currency = "USD", ignoreSmallValue = false, ignoreMinus = true, ignoreZero = false) => {
    if (typeof value === "string") {
        value = Number(value);
    }
    let minus = "";
    let currencySuffix = "";
    // pass ignoreMinus false to get the negative number for currency formatter
    if (!ignoreMinus && value < 0) {
        value = Math.abs(value);
        minus = "-";
    }
    if (value === 0 || !value) {
        // if value is 0, pass ignoreZero true to get this string "<$0.01"
        if (ignoreZero) {
            return "<" + currencyMap.get(currency) + LESS_THAN_ZERO;
        }
        else {
            return currencyMap.get(currency) + ZERO;
        }
    }
    else if (value < 0 || value < 1) {
        if (value < 0.01 && ignoreSmallValue) {
            return "<" + currencyMap.get(currency) + LESS_THAN_ZERO;
        }
    }
    else if (value > 999999999) {
        value = value / 1000000000;
        currencySuffix = "B";
    }
    else if (value > 999999) {
        value = value / 1000000; // convert to M for number from > 1 million
        currencySuffix = "M";
    }
    // Added to round down the number
    const expo = Math.pow(10, decimals);
    value = Math.floor(value * expo) / expo;
    // generates the value with the inputted currency
    const formatter = new Intl.NumberFormat('en-US', {
        style: 'currency',
        currency: currency,
        maximumFractionDigits: decimals,
        currencyDisplay: "symbol"
    });
    //replace the occasional incorrect currency symbol from the formatter and replace with correct symbol from currencyMap
    const regex = new RegExp(`${currency}\\s?`);
    const _val = formatter.format(value).replace(regex, currencyMap.get(currency) ?? "$");
    return minus + _val + currencySuffix;
};

var Chains;
(function (Chains) {
    Chains["BTC_MAINNET"] = "btc-mainnet";
    Chains["ETH_MAINNET"] = "eth-mainnet";
    Chains["MATIC_MAINNET"] = "matic-mainnet";
    Chains["BSC_MAINNET"] = "bsc-mainnet";
    Chains["AVALANCHE_MAINNET"] = "avalanche-mainnet";
    Chains["OPTIMISM_MAINNET"] = "optimism-mainnet";
    Chains["FANTOM_MAINNET"] = "fantom-mainnet";
    Chains["MOONBEAM_MAINNET"] = "moonbeam-mainnet";
    Chains["MOONBEAM_MOONRIVER"] = "moonbeam-moonriver";
    Chains["RSK_MAINNET"] = "rsk-mainnet";
    Chains["ARBITRUM_MAINNET"] = "arbitrum-mainnet";
    Chains["PALM_MAINNET"] = "palm-mainnet";
    Chains["KLAYTN_MAINNET"] = "klaytn-mainnet";
    Chains["HECO_MAINNET"] = "heco-mainnet";
    Chains["NERVOS_GODWOKEN_MAINNET"] = "nervos-godwoken-mainnet";
    Chains["AXIE_MAINNET"] = "axie-mainnet";
    Chains["EVMOS_MAINNET"] = "evmos-mainnet";
    Chains["ASTAR_MAINNET"] = "astar-mainnet";
    Chains["IOTEX_MAINNET"] = "iotex-mainnet";
    Chains["HARMONY_MAINNET"] = "harmony-mainnet";
    Chains["CRONOS_MAINNET"] = "cronos-mainnet";
    Chains["AURORA_MAINNET"] = "aurora-mainnet";
    Chains["EMERALD_PARATIME_MAINNET"] = "emerald-paratime-mainnet";
    Chains["BOBA_MAINNET"] = "boba-mainnet";
    Chains["ETH_GOERLI"] = "eth-goerli";
    Chains["MATIC_MUMBAI"] = "matic-mumbai";
    Chains["AVALANCHE_TESTNET"] = "avalanche-testnet";
    Chains["BSC_TESTNET"] = "bsc-testnet";
    Chains["MOONBEAM_MOONBASE_ALPHA"] = "moonbeam-moonbase-alpha";
    Chains["RSK_TESTNET"] = "rsk-testnet";
    Chains["ARBITRUM_GOERLI"] = "arbitrum-goerli";
    Chains["FANTOM_TESTNET"] = "fantom-testnet";
    Chains["PALM_TESTNET"] = "palm-testnet";
    Chains["HECO_TESTNET"] = "heco-testnet";
    Chains["NERVOS_GODWOKEN_TESTNET"] = "nervos-godwoken-testnet";
    Chains["EVMOS_TESTNET"] = "evmos-testnet";
    Chains["IOTEX_TESTNET"] = "iotex-testnet";
    Chains["HARMONY_TESTNET"] = "harmony-testnet";
    Chains["AURORA_TESTNET"] = "aurora-testnet";
    Chains["SCROLL_L2_TESTNET"] = "scroll-l2-testnet";
    Chains["SCROLL_SEPOLIA_TESTNET"] = "scroll-sepolia-testnet";
    Chains["COVALENT_INTERNAL_NETWORK_V1"] = "covalent-internal-network-v1";
    Chains["DEFI_KINGDOMS_MAINNET"] = "defi-kingdoms-mainnet";
    Chains["SWIMMER_MAINNET"] = "swimmer-mainnet";
    Chains["BOBA_AVALANCHE_MAINNET"] = "boba-avalanche-mainnet";
    Chains["BOBA_BOBABEAM_MAINNET"] = "boba-bobabeam-mainnet";
    Chains["BOBA_BNB_MAINNET"] = "boba-bnb-mainnet";
    Chains["BOBA_RINKEBY_TESTNET"] = "boba-rinkeby-testnet";
    Chains["BOBA_BOBABASE_TESTNET"] = "boba-bobabase-testnet";
    Chains["BOBA_BNB_TESTNET"] = "boba-bnb-testnet";
    Chains["BOBA_AVALANCHE_TESTNET"] = "boba-avalanche-testnet";
    Chains["KLAYTN_TESTNET"] = "klaytn-testnet";
    Chains["GATHER_MAINNET"] = "gather-mainnet";
    Chains["GATHER_TESTNET"] = "gather-testnet";
    Chains["SKALE_CALYPSO"] = "skale-calypso";
    Chains["SKALE_MAINNET"] = "skale-mainnet";
    Chains["SKALE_RAZOR"] = "skale-razor";
    Chains["AVALANCHE_DEXALOT_MAINNET"] = "avalanche-dexalot-mainnet";
    Chains["SKALE_OMNUS"] = "skale-omnus";
    Chains["AVALANCHE_DEXALOT_TESTNET"] = "avalanche-dexalot-testnet";
    Chains["ASTAR_SHIBUYA"] = "astar-shibuya";
    Chains["CRONOS_TESTNET"] = "cronos-testnet";
    Chains["DEFI_KINGDOMS_TESTNET"] = "defi-kingdoms-testnet";
    Chains["METIS_MAINNET"] = "metis-mainnet";
    Chains["METIS_STARDUST"] = "metis-stardust";
    Chains["MILKOMEDA_A1_MAINNET"] = "milkomeda-a1-mainnet";
    Chains["MILKOMEDA_A1_DEVNET"] = "milkomeda-a1-devnet";
    Chains["MILKOMEDA_C1_MAINNET"] = "milkomeda-c1-mainnet";
    Chains["MILKOMEDA_C1_DEVNET"] = "milkomeda-c1-devnet";
    Chains["SWIMMER_TESTNET"] = "swimmer-testnet";
    Chains["SOLANA_MAINNET"] = "solana-mainnet";
    Chains["SKALE_EUROPA"] = "skale-europa";
    Chains["METER_MAINNET"] = "meter-mainnet";
    Chains["METER_TESTNET"] = "meter-testnet";
    Chains["SKALE_EXORDE"] = "skale-exorde";
    Chains["BOBA_GOERLI"] = "boba-goerli";
    Chains["NEON_TESTNET"] = "neon-testnet";
    Chains["SKALE_STAGING_UUM"] = "skale-staging-uum";
    Chains["SKALE_STAGING_LCC"] = "skale-staging-lcc";
    Chains["ARBITRUM_NOVA_MAINNET"] = "arbitrum-nova-mainnet";
    Chains["CANTO_MAINNET"] = "canto-mainnet";
    Chains["BITTORRENT_MAINNET"] = "bittorrent-mainnet";
    Chains["BITTORRENT_TESTNET"] = "bittorrent-testnet";
    Chains["FLARENETWORKS_FLARE_MAINNET"] = "flarenetworks-flare-mainnet";
    Chains["FLARENETWORKS_FLARE_TESTNET"] = "flarenetworks-flare-testnet";
    Chains["FLARENETWORKS_CANARY_MAINNET"] = "flarenetworks-canary-mainnet";
    Chains["FLARENETWORKS_CANARY_TESTNET"] = "flarenetworks-canary-testnet";
    Chains["KCC_MAINNET"] = "kcc-mainnet";
    Chains["KCC_TESTNET"] = "kcc-testnet";
    Chains["POLYGON_ZKEVM_TESTNET"] = "polygon-zkevm-testnet";
    Chains["LINEA_TESTNET"] = "linea-testnet";
    Chains["BASE_TESTNET"] = "base-testnet";
    Chains["MANTLE_TESTNET"] = "mantle-testnet";
    Chains["SCROLL_ALPHA_TESTNET"] = "scroll-alpha-testnet";
    Chains["OASYS_MAINNET"] = "oasys-mainnet";
    Chains["OASYS_TESTNET"] = "oasys-testnet";
    Chains["FINDORA_MAINNET"] = "findora-mainnet";
    Chains["FINDORA_FORGE_TESTNET"] = "findora-forge-testnet";
    Chains["SX_MAINNET"] = "sx-mainnet";
    Chains["OASIS_SAPPHIRE_MAINNET"] = "oasis-sapphire-mainnet";
    Chains["OASIS_SAPPHIRE_TESTNET"] = "oasis-sapphire-testnet";
    Chains["OPTIMISM_GOERLI"] = "optimism-goerli";
    Chains["POLYGON_ZKEVM_MAINNET"] = "polygon-zkevm-mainnet";
    Chains["HORIZEN_YUMA_TESTNET"] = "horizen-yuma-testnet";
    Chains["CLV_PARACHAIN"] = "clv-parachain";
    Chains["ENERGI_MAINNET"] = "energi-mainnet";
    Chains["ENERGI_TESTNET"] = "energi-testnet";
    Chains["HORIZEN_GOBI_TESTNET"] = "horizen-gobi-testnet";
    Chains["ETH_SEPOLIA"] = "eth-sepolia";
    Chains["SKALE_NEBULA"] = "skale-nebula";
    Chains["SKALE_BATTLEGROUND"] = "skale-battleground";
    Chains["AVALANCHE_MELD_TESTNET"] = "avalanche-meld-testnet";
    Chains["GUNZILLA_TESTNET"] = "gunzilla-testnet";
    Chains["ULTRON_MAINNET"] = "ultron-mainnet";
    Chains["ULTRON_TESTNET"] = "ultron-testnet";
    Chains["ZORA_MAINNET"] = "zora-mainnet";
    Chains["ZORA_GOERLI_TESTNET"] = "zora-goerli-testnet";
    Chains["NEON_MAINNET"] = "neon-mainnet";
    Chains["AVALANCHE_SHRAPNEL_MAINNET"] = "avalanche-shrapnel-mainnet";
    Chains["BASE_MAINNET"] = "base-mainnet";
    Chains["MANTLE_MAINNET"] = "mantle-mainnet";
    Chains["AVALANCHE_LOCO_LEGENDS_MAINNET"] = "avalanche-loco-legends-mainnet";
    Chains["LINEA_MAINNET"] = "linea-mainnet";
    Chains["HORIZEN_EON_MAINNET"] = "horizen-eon-mainnet";
    Chains["AVALANCHE_NUMBERS"] = "avalanche-numbers";
    Chains["AVALANCHE_DOS"] = "avalanche-dos";
    Chains["AVALANCHE_STEP_NETWORK"] = "avalanche-step-network";
    Chains["AVALANCHE_XPLUS"] = "avalanche-xplus";
    Chains["AVALANCHE_XANACHAIN"] = "avalanche-xanachain";
    Chains["AVALANCHE_MELD_MAINNET"] = "avalanche-meld-mainnet";
    Chains["OPSIDE_PUBLIC_ZKEVM"] = "opside-public-zkevm";
    Chains["OPSIDE_LAW_CHAIN"] = "opside-law-chain";
    Chains["AVALANCHE_SHRAPNEL_TESTNET"] = "avalanche-shrapnel-testnet";
    Chains["AVALANCHE_LOCO_LEGENDS_TESTNET"] = "avalanche-loco-legends-testnet";
    Chains["OPSIDE_CB_ZKEVM"] = "opside-cb-zkevm";
    Chains["OPSIDE_PRE_ALPHA_TESTNET"] = "opside-pre-alpha-testnet";
    Chains["OPSIDE_ERA7"] = "opside-era7";
    Chains["OPSIDE_XTHRILL"] = "opside-xthrill";
    Chains["ZKSYNC_MAINNET"] = "zksync-mainnet";
    Chains["METIS_TESTNET"] = "metis-testnet";
    Chains["ZKSYNC_TESTNET"] = "zksync-testnet";
    Chains["AVALANCHE_BLITZ_TESTNET"] = "avalanche-blitz-testnet";
    Chains["AVALANCHE_D_CHAIN_TESTNET"] = "avalanche-d-chain-testnet";
    Chains["AVALANCHE_GREEN_DOT_TESTNET"] = "avalanche-green-dot-testnet";
    Chains["AVALANCHE_MINTARA_TESTNET"] = "avalanche-mintara-testnet";
    Chains["AVALANCHE_BEAM_TESTNET"] = "avalanche-beam-testnet";
    Chains["BNB_META_APES_MAINNET"] = "bnb-meta-apes-mainnet";
    Chains["BNB_ANTIMATTER_MAINNET"] = "bnb-antimatter-mainnet";
    Chains["BNB_ANTIMATTER_TESTNET"] = "bnb-antimatter-testnet";
    Chains["BNB_OPBNB_TESTNET"] = "bnb-opbnb-testnet";
    Chains["OPSIDE_DEBOX"] = "opside-debox";
    Chains["OPSIDE_JACKBOT"] = "opside-jackbot";
    Chains["OPSIDE_ODX_ZKEVM_TESTNET"] = "opside-odx-zkevm-testnet";
    Chains["OPSIDE_READON_CONTENT_TESTNET"] = "opside-readon-content-testnet";
    Chains["OPSIDE_RELATION"] = "opside-relation";
    Chains["OPSIDE_SOQUEST_ZKEVM"] = "opside-soquest-zkevm";
    Chains["OPSIDE_VIP3"] = "opside-vip3";
    Chains["OPSIDE_ZKMETA"] = "opside-zkmeta";
    Chains["AVALANCHE_PULSAR_TESTNET"] = "avalanche-pulsar-testnet";
    Chains["AVALANCHE_UPTN"] = "avalanche-uptn";
    Chains["BNB_FNCY_MAINNET"] = "bnb-fncy-mainnet";
    Chains["ZETACHAIN_TESTNET"] = "zetachain-testnet";
    Chains["KINTO_TESTNET"] = "kinto-testnet";
    Chains["MODE_TESTNET"] = "mode-testnet";
    Chains["LOOT_MAINNET"] = "loot-mainnet";
    Chains["BNB_FNCY_TESTNET"] = "bnb-fncy-testnet";
    Chains["MANTA_TESTNET"] = "manta-testnet";
    Chains["PGN_MAINNET"] = "pgn-mainnet";
    Chains["PGN_TESTNET"] = "pgn-testnet";
    Chains["GNOSIS_MAINNET"] = "gnosis-mainnet";
    Chains["GNOSIS_TESTNET"] = "gnosis-testnet";
    Chains["ROLLUX_MAINNET"] = "rollux-mainnet";
    Chains["ROLLUX_TESTNET"] = "rollux-testnet";
    Chains["TAIKO_JOLNIR_TESTNET"] = "taiko-jolnir-testnet";
    Chains["OPTIMISM_SEPOLIA"] = "optimism-sepolia";
    Chains["BNB_OPBNB_MAINNET"] = "bnb-opbnb-mainnet";
    Chains["TELOS_MAINNET"] = "telos-mainnet";
    Chains["TELOS_TESTNET"] = "telos-testnet";
    Chains["AVALANCHE_HUBBLE_EXCHANGE_TESTNET"] = "avalanche-hubble-exchange-testnet";
    Chains["AVALANCHE_MIHO_TESTNET"] = "avalanche-miho-testnet";
    Chains["AVALANCHE_BULLETIN_TESTNET"] = "avalanche-bulletin-testnet";
    Chains["AVALANCHE_KIWI_TESTNET"] = "avalanche-kiwi-testnet";
    Chains["AVALANCHE_HERO_TESTNET"] = "avalanche-hero-testnet";
    Chains["AVALANCHE_AVACLOUD_TESTNET"] = "avalanche-avacloud-testnet";
    Chains["AVALANCHE_THIRDWEB_TESTNET"] = "avalanche-thirdweb-testnet";
    Chains["AVALANCHE_MONDRIAN_TESTNET"] = "avalanche-mondrian-testnet";
    Chains["AVALANCHE_CONDUIT_TESTNET"] = "avalanche-conduit-testnet";
    Chains["AVALANCHE_NMAC_TESTNET"] = "avalanche-nmac-testnet";
    Chains["AVALANCHE_ORDERLY_TESTNET"] = "avalanche-orderly-testnet";
    Chains["AVALANCHE_AMPLIFY_TESTNET"] = "avalanche-amplify-testnet";
    Chains["AVALANCHE_MIRAI_TESTNET"] = "avalanche-mirai-testnet";
    Chains["AVALANCHE_WAGMI_TESTNET"] = "avalanche-wagmi-testnet";
    Chains["AVALANCHE_PLAYA3ULL_TESTNET"] = "avalanche-playa3ull-testnet";
    Chains["AVALANCHE_BEAM_MAINNET"] = "avalanche-beam-mainnet";
    Chains["SCROLL_MAINNET"] = "scroll-mainnet";
    Chains["ETH_HOLESKY"] = "eth-holesky";
    Chains["TOMOCHAIN_MAINNET"] = "tomochain-mainnet";
    Chains["TOMOCHAIN_TESTNET"] = "tomochain-testnet";
    Chains["AVALANCHE_JONO11_TESTNET"] = "avalanche-jono11-testnet";
    Chains["BASE_SEPOLIA_TESTNET"] = "base-sepolia-testnet";
    Chains["XAI_TESTNET"] = "xai-testnet";
    Chains["ARBITRUM_SEPOLIA"] = "arbitrum-sepolia";
    Chains["LUMOZ_PUBLIC_ZKSYNC_V2"] = "lumoz-public-zksync-v2";
    Chains["LUMOZ_DECIBLING"] = "lumoz-decibling";
    Chains["LUMOZ_STARK_SPORT"] = "lumoz-stark-sport";
    Chains["AVALANCHE_LT0_TESTNET"] = "avalanche-lt0-testnet";
    Chains["AVALANCHE_LT1_TESTNET"] = "avalanche-lt1-testnet";
    Chains["AVALANCHE_LT2_TESTNET"] = "avalanche-lt2-testnet";
    Chains["AVALANCHE_LT3_TESTNET"] = "avalanche-lt3-testnet";
    Chains["AVALANCHE_LT4_TESTNET"] = "avalanche-lt4-testnet";
    Chains["AVALANCHE_LT5_TESTNET"] = "avalanche-lt5-testnet";
    Chains["SYNDR_TESTNET"] = "syndr-testnet";
    Chains["CROSSFI_EVM_TESTNET"] = "crossfi-evm-testnet";
    Chains["CELO_MAINNET"] = "celo-mainnet";
    Chains["TAIKO_KATLA_TESTNET"] = "taiko-katla-testnet";
    Chains["MOVEMENT_MEVM_TESTNET"] = "movement-mevm-testnet";
    Chains["ZORA_SEPOLIA_TESTNET"] = "zora-sepolia-testnet";
    Chains["MERLIN_MAINNET"] = "merlin-mainnet";
    Chains["MERLIN_TESTNET"] = "merlin-testnet";
    Chains["AVALANCHE_HUBBLE_EXCHANGE_MAINNET"] = "avalanche-hubble-exchange-mainnet";
    Chains["XAI_MAINNET"] = "xai-mainnet";
})(Chains || (Chains = {}));

export { BalanceService, BaseService, Chains, Client, CovalentClient, NftService, Response$1 as PriceResponse, PricingService, Response, SecurityService, TransactionService, XykService, calculatePrettyBalance, prettifyCurrency };
//# sourceMappingURL=index.js.map
