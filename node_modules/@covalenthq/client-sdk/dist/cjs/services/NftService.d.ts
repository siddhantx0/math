import { Chain, Quote, Response, ChainID, Source } from "./CovalentClient";
import { Chains } from "../util/Chains";
declare class ChainCollectionResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested chain ID eg: `1`. */
    chain_id: number;
    /** * The requested chain name eg: `eth-mainnet`. */
    chain_name: string;
    /** * List of response items. */
    items: ChainCollectionItem[];
    /** * Pagination metadata. */
    pagination: Pagination;
    constructor(data: ChainCollectionResponse);
}
declare class ChainCollectionItem {
    /** * Use the relevant `contract_address` to lookup prices, logos, token transfers, etc. */
    contract_address: string;
    /** * The string returned by the `name()` method. */
    contract_name: string;
    /** * Denotes whether the token is suspected spam. Supports `eth-mainnet` and `matic-mainnet`. */
    is_spam: boolean;
    token_total_supply: number;
    cached_metadata_count: number;
    cached_asset_count: number;
    last_scraped_at: Date;
    constructor(data: ChainCollectionItem);
}
declare class Pagination {
    /** * True is there is another page. */
    has_more: boolean;
    /** * The requested page number. */
    page_number: number;
    /** * The requested number of items on the current page. */
    page_size: number;
    /** * The total number of items across all pages for this request. */
    total_count: number;
    constructor(data: Pagination);
}
declare class NftAddressBalanceNftResponse {
    /** * The requested address. */
    address: string;
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * List of response items. */
    items: NftTokenContractBalanceItem[];
    constructor(data: NftAddressBalanceNftResponse);
}
declare class NftTokenContractBalanceItem {
    /** * The string returned by the `name()` method. */
    contract_name: string;
    /** * The ticker symbol for this contract. This field is set by a developer and non-unique across a network. */
    contract_ticker_symbol: string;
    /** * Use the relevant `contract_address` to lookup prices, logos, token transfers, etc. */
    contract_address: string;
    /** * A list of supported standard ERC interfaces, eg: `ERC20` and `ERC721`. */
    supports_erc: string[];
    /** * Denotes whether the token is suspected spam. Supports `eth-mainnet` and `matic-mainnet`. */
    is_spam: boolean;
    last_transfered_at: Date;
    /** * The asset balance. Use `contract_decimals` to scale this balance for display purposes. */
    balance: bigint | null;
    balance_24h: string;
    type: string;
    /** * The current floor price converted to fiat in `quote-currency`. The floor price is determined by the last minimum sale price within the last 30 days across all the supported markets where the collection is sold on. */
    floor_price_quote: number;
    /** * A prettier version of the floor price quote for rendering purposes. */
    pretty_floor_price_quote: string;
    /** * The current floor price in native currency. The floor price is determined by the last minimum sale price within the last 30 days across all the supported markets where the collection is sold on. */
    floor_price_native_quote: number;
    nft_data: NftData[];
    constructor(data: NftTokenContractBalanceItem);
}
declare class NftData {
    /** * The token's id. */
    token_id: bigint | null;
    token_url: string;
    /** * The original minter. */
    original_owner: string;
    /** * The current holder of this NFT. */
    current_owner: string;
    external_data: NftExternalData;
    /** * If `true`, the asset data is available from the Covalent CDN. */
    asset_cached: boolean;
    /** * If `true`, the image data is available from the Covalent CDN. */
    image_cached: boolean;
    constructor(data: NftData);
}
declare class NftExternalData {
    name: string;
    description: string;
    asset_url: string;
    asset_file_extension: string;
    asset_mime_type: string;
    asset_size_bytes: string;
    image: string;
    image_256: string;
    image_512: string;
    image_1024: string;
    animation_url: string;
    external_url: string;
    attributes: NftCollectionAttribute[];
    constructor(data: NftExternalData);
}
declare class NftCollectionAttribute {
    trait_type: string;
    value: string;
    constructor(data: NftCollectionAttribute);
}
declare class NftMetadataResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * List of response items. */
    items: NftTokenContract[];
    /** * Pagination metadata. */
    pagination: Pagination;
    constructor(data: NftMetadataResponse);
}
declare class NftTokenContract {
    /** * The string returned by the `name()` method. */
    contract_name: string;
    /** * The ticker symbol for this contract. This field is set by a developer and non-unique across a network. */
    contract_ticker_symbol: string;
    /** * Use the relevant `contract_address` to lookup prices, logos, token transfers, etc. */
    contract_address: string;
    /** * Denotes whether the token is suspected spam. Supports `eth-mainnet` and `matic-mainnet`. */
    is_spam: boolean;
    type: string;
    nft_data: NftData;
    constructor(data: NftTokenContract);
}
declare class NftTransactionsResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested chain ID eg: `1`. */
    chain_id: number;
    /** * The requested chain name eg: `eth-mainnet`. */
    chain_name: string;
    /** * List of response items. */
    items: NftTransaction[];
    constructor(data: NftTransactionsResponse);
}
declare class NftTransaction {
    /** * Use contract decimals to format the token balance for display purposes - divide the balance by `10^{contract_decimals}`. */
    contract_decimals: number;
    /** * The string returned by the `name()` method. */
    contract_name: string;
    /** * The ticker symbol for this contract. This field is set by a developer and non-unique across a network. */
    contract_ticker_symbol: string;
    /** * The contract logo URL. */
    logo_url: string;
    /** * Use the relevant `contract_address` to lookup prices, logos, token transfers, etc. */
    contract_address: string;
    /** * A list of supported standard ERC interfaces, eg: `ERC20` and `ERC721`. */
    supports_erc: string[];
    nft_transactions: NftTransactionItem[];
    /** * Denotes whether the token is suspected spam. Supports `eth-mainnet` and `matic-mainnet`. */
    is_spam: boolean;
    constructor(data: NftTransaction);
}
declare class NftTransactionItem {
    /** * The block signed timestamp in UTC. */
    block_signed_at: Date;
    /** * The height of the block. */
    block_height: number;
    /** * The requested transaction hash. */
    tx_hash: string;
    /** * The offset is the position of the tx in the block. */
    tx_offset: number;
    /** * Whether or not transaction is successful. */
    successful: boolean;
    /** * The sender's wallet address. */
    from_address: string;
    /** * The label of `from` address. */
    from_address_label: string;
    /** * The receiver's wallet address. */
    to_address: string;
    /** * The label of `to` address. */
    to_address_label: string;
    /** * The value attached to this tx. */
    value: bigint | null;
    /** * The value attached in `quote-currency` to this tx. */
    value_quote: number;
    /** * A prettier version of the quote for rendering purposes. */
    pretty_value_quote: string;
    gas_offered: number;
    /** * The gas spent for this tx. */
    gas_spent: number;
    /** * The gas price at the time of this tx. */
    gas_price: number;
    /** * The total transaction fees (gas_price * gas_spent) paid for this tx, denoted in wei. */
    fees_paid: bigint | null;
    /** * The gas spent in `quote-currency` denomination. */
    gas_quote: number;
    /** * A prettier version of the quote for rendering purposes. */
    pretty_gas_quote: string;
    gas_quote_rate: number;
    /** * The log events. */
    log_events: LogEvent[];
    constructor(data: NftTransactionItem);
}
declare class LogEvent {
    /** * The block signed timestamp in UTC. */
    block_signed_at: Date;
    /** * The height of the block. */
    block_height: number;
    /** * The offset is the position of the tx in the block. */
    tx_offset: number;
    /** * The offset is the position of the log entry within an event log. */
    log_offset: number;
    /** * The requested transaction hash. */
    tx_hash: string;
    /** * The log topics in raw data. */
    raw_log_topics: string[];
    /** * Use contract decimals to format the token balance for display purposes - divide the balance by `10^{contract_decimals}`. */
    sender_contract_decimals: number;
    /** * The name of the sender. */
    sender_name: string;
    sender_contract_ticker_symbol: string;
    /** * The address of the sender. */
    sender_address: string;
    /** * The label of the sender address. */
    sender_address_label: string;
    /** * The contract logo URL. */
    sender_logo_url: string;
    /** * A list of supported standard ERC interfaces, eg: `ERC20` and `ERC721`. */
    supports_erc: string[];
    /** * The address of the deployed UniswapV2 like factory contract for this DEX. */
    sender_factory_address: string;
    /** * The log events in raw. */
    raw_log_data: string;
    /** * The decoded item. */
    decoded: DecodedItem;
    constructor(data: LogEvent);
}
declare class DecodedItem {
    name: string;
    signature: string;
    params: Param[];
    constructor(data: DecodedItem);
}
declare class Param {
    name: string;
    type: string;
    indexed: boolean;
    decoded: boolean;
    value: string;
    constructor(data: Param);
}
declare class NftCollectionTraitsResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * List of response items. */
    items: NftTrait[];
    constructor(data: NftCollectionTraitsResponse);
}
declare class NftTrait {
    name: string;
    constructor(data: NftTrait);
}
declare class NftCollectionAttributesForTraitResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * List of response items. */
    items: NftSummaryAttribute[];
    constructor(data: NftCollectionAttributesForTraitResponse);
}
declare class NftSummaryAttribute {
    trait_type: string;
    values: NftAttribute[];
    unique_values: number;
    constructor(data: NftSummaryAttribute);
}
declare class NftAttribute {
    value: string;
    count: number;
    constructor(data: NftAttribute);
}
declare class NftCollectionTraitSummaryResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * List of response items. */
    items: NftTraitSummary[];
    constructor(data: NftCollectionTraitSummaryResponse);
}
declare class NftTraitSummary {
    /** * Trait name */
    name: string;
    /** * Type of the value of the trait. */
    value_type: string;
    /** * Populated for `numeric` traits. */
    value_numeric: NftTraitNumeric;
    /** * Populated for `string` traits. */
    value_string: NftTraitString;
    attributes: NftSummaryAttribute[];
    constructor(data: NftTraitSummary);
}
declare class NftTraitNumeric {
    min: number;
    max: number;
    constructor(data: NftTraitNumeric);
}
declare class NftTraitString {
    /** * String value */
    value: string;
    /** * Number of distinct tokens that have this trait value. */
    token_count: number;
    /** * Percentage of tokens in the collection that have this trait. */
    trait_percentage: number;
    constructor(data: NftTraitString);
}
declare class NftOwnershipForCollectionResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested address. */
    address: string;
    /** * The requested collection. */
    collection: string;
    /** * Denotes whether the token is suspected spam. Supports `eth-mainnet` and `matic-mainnet`. */
    is_spam: boolean;
    /** * List of response items. */
    items: NftOwnershipForCollectionItem[];
    constructor(data: NftOwnershipForCollectionResponse);
}
declare class NftOwnershipForCollectionItem {
    /** * The string returned by the `name()` method. */
    contract_name: string;
    /** * The ticker symbol for this contract. This field is set by a developer and non-unique across a network. */
    contract_ticker_symbol: string;
    /** * Use the relevant `contract_address` to lookup prices, logos, token transfers, etc. */
    contract_address: string;
    /** * The token's id. */
    token_id: bigint | null;
    /** * A list of supported standard ERC interfaces, eg: `ERC20` and `ERC721`. */
    supports_erc: string[];
    last_transfered_at: Date;
    /** * Nft balance. */
    balance: bigint | null;
    balance_24h: string;
    type: string;
    nft_data: NftData;
    constructor(data: NftOwnershipForCollectionItem);
}
declare class NftMarketSaleCountResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested address. */
    address: string;
    /** * The requested quote currency eg: `USD`. */
    quote_currency: string;
    /** * The requested chain name eg: `eth-mainnet`. */
    chain_name: string;
    /** * The requested chain ID eg: `1`. */
    chain_id: number;
    /** * List of response items. */
    items: MarketSaleCountItem[];
    constructor(data: NftMarketSaleCountResponse);
}
declare class MarketSaleCountItem {
    /** * The timestamp of the date of sale. */
    date: Date;
    /** * The total amount of sales for the current day. */
    sale_count: number;
    constructor(data: MarketSaleCountItem);
}
declare class NftMarketVolumeResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested address. */
    address: string;
    /** * The requested quote currency eg: `USD`. */
    quote_currency: string;
    /** * The requested chain name eg: `eth-mainnet`. */
    chain_name: string;
    /** * The requested chain ID eg: `1`. */
    chain_id: number;
    /** * List of response items. */
    items: MarketVolumeItem[];
    constructor(data: NftMarketVolumeResponse);
}
declare class MarketVolumeItem {
    /** * The timestamp of the date of sale. */
    date: Date;
    /** * The ticker symbol for the native currency. */
    native_ticker_symbol: string;
    /** * The contract name of the native currency. */
    native_name: string;
    /** * The current volume converted to fiat in `quote-currency`. */
    volume_quote: number;
    /** * The current volume in native currency. */
    volume_native_quote: number;
    /** * A prettier version of the volume quote for rendering purposes. */
    pretty_volume_quote: string;
    constructor(data: MarketVolumeItem);
}
declare class NftMarketFloorPriceResponse {
    /** * The timestamp when the response was generated. Useful to show data staleness to users. */
    updated_at: Date;
    /** * The requested address. */
    address: string;
    /** * The requested quote currency eg: `USD`. */
    quote_currency: string;
    /** * The requested chain name eg: `eth-mainnet`. */
    chain_name: string;
    /** * The requested chain ID eg: `1`. */
    chain_id: number;
    /** * List of response items. */
    items: MarketFloorPriceItem[];
    constructor(data: NftMarketFloorPriceResponse);
}
declare class MarketFloorPriceItem {
    /** * The timestamp of the date of sale. */
    date: Date;
    /** * The ticker symbol for the native currency. */
    native_ticker_symbol: string;
    /** * The contract name of the native currency. */
    native_name: string;
    /** * The current floor price in native currency. */
    floor_price_native_quote: number;
    /** * The current floor price converted to fiat in `quote-currency`. */
    floor_price_quote: number;
    /** * A prettier version of the floor price quote for rendering purposes. */
    pretty_floor_price_quote: string;
    constructor(data: MarketFloorPriceItem);
}
export interface GetChainCollectionsQueryParamOpts {
    /** * Number of items per page. Omitting this parameter defaults to 100. */
    pageSize?: number;
    /** * 0-indexed page number to begin pagination. */
    pageNumber?: number;
    /** * If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`. */
    noSpam?: boolean;
}
export interface GetNftsForAddressQueryParamOpts {
    /** * If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`. */
    noSpam?: boolean;
    /** * If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs. */
    noNftAssetMetadata?: boolean;
    /** * By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side. */
    withUncached?: boolean;
}
export interface GetTokenIdsForContractWithMetadataQueryParamOpts {
    /** * Omit metadata. */
    noMetadata?: boolean;
    /** * Number of items per page. Omitting this parameter defaults to 100. */
    pageSize?: number;
    /** * 0-indexed page number to begin pagination. */
    pageNumber?: number;
    /** * Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding. */
    traitsFilter?: string;
    /** * Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding. */
    valuesFilter?: string;
    /** * By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side. */
    withUncached?: boolean;
}
export interface GetNftMetadataForGivenTokenIdForContractQueryParamOpts {
    /** * Omit metadata. */
    noMetadata?: boolean;
    /** * By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side. */
    withUncached?: boolean;
}
export interface GetNftTransactionsForContractTokenIdQueryParamOpts {
    /** * If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`. */
    noSpam?: boolean;
}
export interface CheckOwnershipInNftQueryParamOpts {
    /** * Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Must be used with "values-filter", is case-sensitive, and requires proper URL encoding. */
    traitsFilter?: string;
    /** * Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. Must be used with "traits-filter", is case-sensitive, and requires proper URL encoding. */
    valuesFilter?: string;
}
export interface GetNftMarketSaleCountQueryParamOpts {
    /** * The number of days to return data for. Request up 365 days. Defaults to 30 days. */
    days?: number;
    /** * The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`. */
    quoteCurrency?: Quote;
}
export interface GetNftMarketVolumeQueryParamOpts {
    /** * The number of days to return data for. Request up 365 days. Defaults to 30 days. */
    days?: number;
    /** * The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`. */
    quoteCurrency?: Quote;
}
export interface GetNftMarketFloorPriceQueryParamOpts {
    /** * The number of days to return data for. Request up 365 days. Defaults to 30 days. */
    days?: number;
    /** * The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`. */
    quoteCurrency?: Quote;
}
/**
 * NFT APIs
 *
 */
export declare class NftService {
    private apiKey;
    private debug;
    private threadCount;
    private is_key_valid;
    private enableRetry;
    private source;
    private LIMIT;
    constructor(apiKey: string, debug: boolean, threadCount: number, is_key_valid: boolean, enableRetry: boolean, source: Source);
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    getChainCollections(chainName: Chain | Chains | ChainID, queryParamOpts?: GetChainCollectionsQueryParamOpts): AsyncIterable<ChainCollectionItem>;
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    getChainCollectionsByPage(chainName: Chain | Chains | ChainID, queryParamOpts?: GetChainCollectionsQueryParamOpts): Promise<Response<ChainCollectionResponse>>;
    /**
     *
     * Commonly used to render the NFTs (including ERC721 and ERC1155) held by an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftsForAddressQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    getNftsForAddress(chainName: Chain | Chains | ChainID, walletAddress: string, queryParamOpts?: GetNftsForAddressQueryParamOpts): Promise<Response<NftAddressBalanceNftResponse>>;
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    getTokenIdsForContractWithMetadata(chainName: Chain | Chains | ChainID, contractAddress: string, queryParamOpts?: GetTokenIdsForContractWithMetadataQueryParamOpts): AsyncIterable<NftTokenContract>;
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    getTokenIdsForContractWithMetadataByPage(chainName: Chain | Chains | ChainID, contractAddress: string, queryParamOpts?: GetTokenIdsForContractWithMetadataQueryParamOpts): Promise<Response<NftMetadataResponse>>;
    /**
     *
     * Commonly used to get a single NFT metadata by token ID from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftMetadataForGivenTokenIdForContractQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    getNftMetadataForGivenTokenIdForContract(chainName: Chain | Chains | ChainID, contractAddress: string, tokenId: string, queryParamOpts?: GetNftMetadataForGivenTokenIdForContractQueryParamOpts): Promise<Response<NftMetadataResponse>>;
    /**
     *
     * Commonly used to get all transactions of an NFT token. Useful for building a transaction history table or price chart.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftTransactionsForContractTokenIdQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    getNftTransactionsForContractTokenId(chainName: Chain | Chains | ChainID, contractAddress: string, tokenId: string, queryParamOpts?: GetNftTransactionsForContractTokenIdQueryParamOpts): Promise<Response<NftTransactionsResponse>>;
    /**
     *
     * Commonly used to fetch and render the traits of a collection as seen in rarity calculators.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    getTraitsForCollection(chainName: Chain | Chains | ChainID, collectionContract: string): Promise<Response<NftCollectionTraitsResponse>>;
    /**
     *
     * Commonly used to get the count of unique values for traits within an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} trait - The requested trait.
     *
     */
    getAttributesForTraitInCollection(chainName: Chain | Chains | ChainID, collectionContract: string, trait: string): Promise<Response<NftCollectionAttributesForTraitResponse>>;
    /**
     *
     * Commonly used to calculate rarity scores for a collection based on its traits.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    getCollectionTraitsSummary(chainName: Chain | Chains | ChainID, collectionContract: string): Promise<Response<NftCollectionTraitSummaryResponse>>;
    /**
     *
     * Commonly used to verify ownership of NFTs (including ERC-721 and ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address.
     * @param {CheckOwnershipInNftQueryParamOpts} queryParamOpts
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Must be used with "values-filter", is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. Must be used with "traits-filter", is case-sensitive, and requires proper URL encoding.
     *
     */
    checkOwnershipInNft(chainName: Chain | Chains | ChainID, walletAddress: string, collectionContract: string, queryParamOpts?: CheckOwnershipInNftQueryParamOpts): Promise<Response<NftOwnershipForCollectionResponse>>;
    /**
     *
     * Commonly used to verify ownership of a specific token (ERC-721 or ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     *
     */
    checkOwnershipInNftForSpecificTokenId(chainName: Chain | Chains | ChainID, walletAddress: string, collectionContract: string, tokenId: string): Promise<Response<NftOwnershipForCollectionResponse>>;
    /**
     *
     * Commonly used to build a time-series chart of the sales count of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketSaleCountQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    getNftMarketSaleCount(chainName: Chain | Chains | ChainID, contractAddress: string, queryParamOpts?: GetNftMarketSaleCountQueryParamOpts): Promise<Response<NftMarketSaleCountResponse>>;
    /**
     *
     * Commonly used to build a time-series chart of the transaction volume of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketVolumeQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    getNftMarketVolume(chainName: Chain | Chains | ChainID, contractAddress: string, queryParamOpts?: GetNftMarketVolumeQueryParamOpts): Promise<Response<NftMarketVolumeResponse>>;
    /**
     *
     * Commonly used to render a price floor chart for an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketFloorPriceQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    getNftMarketFloorPrice(chainName: Chain | Chains | ChainID, contractAddress: string, queryParamOpts?: GetNftMarketFloorPriceQueryParamOpts): Promise<Response<NftMarketFloorPriceResponse>>;
}
export {};
