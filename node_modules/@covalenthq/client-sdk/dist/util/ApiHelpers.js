import { ExponentialBackoff } from "./backoff";
import { userAgent } from "../services/CovalentClient";
import pLimit from "p-limit";
export function checkAndModifyResponse(jsonObj) {
    for (const key in jsonObj) {
        if (key === 'next_update_at') {
            delete jsonObj[key];
        }
        else if (typeof jsonObj[key] === 'object') {
            checkAndModifyResponse(jsonObj[key]);
        }
    }
}
export async function debugOutput(url, responseStatus, startTime) {
    let endTime;
    let elapsedTime;
    if (startTime === undefined) {
        return;
    }
    endTime = new Date();
    elapsedTime = endTime.getTime() - startTime.getTime();
    console.log("[DEBUG]" + " |" + " Request URL: " + url + " |" + " Response code: " + responseStatus + " |" + " Response time: " + elapsedTime.toFixed(2) + "ms");
}
export async function* paginateEndpoint(url, apiKey, urlsParams, dataClassConstructor, debug, threadCount, enableRetry, source) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    let page_number = 0;
    const LIMIT = pLimit(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = new Date();
            }
            const link = urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`;
            response = await LIMIT(() => fetch(urlsParams.get("page-number") ? `${url}?${urlsParams}` : `${url}?${urlsParams}&page-number=${page_number}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": source ? source + " " + "(" + userAgent + ")" : userAgent
                }
            }));
            debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
            if ((enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                try {
                    data = await LIMIT(() => backoff.backOff(response ? response.url : link, source));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response ? response.status : 429}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new dataClassConstructor(tx);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.pagination !== null && data.data.pagination.has_more === false) {
                    hasNext = false;
                }
                if (urlsParams.get("page-number")) {
                    const next_page = parseInt(urlsParams.get("page-number")) + 1;
                    urlsParams.set("page-number", next_page.toString());
                }
                else {
                    page_number = page_number + 1;
                }
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response ? response.status : "Unknown Error Code"}: ${data ? data.error_message : response && response.status === 500 ? "Internal server error" : "Unknown Error"}`);
        }
    }
}
//# sourceMappingURL=ApiHelpers.js.map