import { userAgent } from "./CovalentClient";
import { debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class TransactionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class Transaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.miner_address = data.miner_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.dex_details = data.dex_details && data.dex_details !== null ? data.dex_details.map((itemData) => new DexReport(itemData)) : null;
        this.nft_sale_details = data.nft_sale_details && data.nft_sale_details !== null ? data.nft_sale_details.map((itemData) => new NftSalesReport(itemData)) : null;
        this.lending_details = data.lending_details && data.lending_details !== null ? data.lending_details.map((itemData) => new LendingReport(itemData)) : null;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent(itemData)) : null;
        this.safe_details = data.safe_details && data.safe_details !== null ? data.safe_details.map((itemData) => new SafeDetails(itemData)) : null;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
}
class DexReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.aggregator_name = data.aggregator_name;
        this.aggregator_address = data.aggregator_address;
        this.version = data.version;
        this.fork_version = data.fork_version;
        this.fork = data.fork;
        this.event = data.event;
        this.pair_address = data.pair_address;
        this.pair_lp_fee_bps = data.pair_lp_fee_bps;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_ticker = data.lp_token_ticker;
        this.lp_token_num_decimals = data.lp_token_num_decimals;
        this.lp_token_name = data.lp_token_name;
        this.lp_token_value = data.lp_token_value;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_0_address = data.token_0_address;
        this.token_0_ticker = data.token_0_ticker;
        this.token_0_num_decimals = data.token_0_num_decimals;
        this.token_0_name = data.token_0_name;
        this.token_1_address = data.token_1_address;
        this.token_1_ticker = data.token_1_ticker;
        this.token_1_num_decimals = data.token_1_num_decimals;
        this.token_1_name = data.token_1_name;
        this.token_0_amount = data.token_0_amount;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_0_usd_quote = data.token_0_usd_quote;
        this.pretty_token_0_usd_quote = data.pretty_token_0_usd_quote;
        this.token_0_logo_url = data.token_0_logo_url;
        this.token_1_amount = data.token_1_amount;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.token_1_usd_quote = data.token_1_usd_quote;
        this.pretty_token_1_usd_quote = data.pretty_token_1_usd_quote;
        this.token_1_logo_url = data.token_1_logo_url;
        this.sender = data.sender;
        this.recipient = data.recipient;
    }
}
class NftSalesReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.topic0 = data.topic0;
        this.protocol_contract_address = data.protocol_contract_address;
        this.protocol_name = data.protocol_name;
        this.protocol_logo_url = data.protocol_logo_url;
        this.to = data.to;
        this.from = data.from;
        this.maker = data.maker;
        this.taker = data.taker;
        this.token_id = data.token_id;
        this.collection_address = data.collection_address;
        this.collection_name = data.collection_name;
        this.token_address = data.token_address;
        this.token_name = data.token_name;
        this.ticker_symbol = data.ticker_symbol;
        this.num_decimals = data.num_decimals;
        this.contract_quote_rate = data.contract_quote_rate;
        this.nft_token_price = data.nft_token_price;
        this.nft_token_price_usd = data.nft_token_price_usd;
        this.pretty_nft_token_price_usd = data.pretty_nft_token_price_usd;
        this.nft_token_price_native = data.nft_token_price_native;
        this.pretty_nft_token_price_native = data.pretty_nft_token_price_native;
        this.token_count = data.token_count;
        this.num_token_ids_sold_per_sale = data.num_token_ids_sold_per_sale;
        this.num_token_ids_sold_per_tx = data.num_token_ids_sold_per_tx;
        this.num_collections_sold_per_sale = data.num_collections_sold_per_sale;
        this.num_collections_sold_per_tx = data.num_collections_sold_per_tx;
        this.trade_type = data.trade_type;
        this.trade_group_type = data.trade_group_type;
    }
}
class LendingReport {
    constructor(data) {
        this.log_offset = data.log_offset;
        this.protocol_name = data.protocol_name;
        this.protocol_address = data.protocol_address;
        this.protocol_logo_url = data.protocol_logo_url;
        this.version = data.version;
        this.fork = data.fork;
        this.fork_version = data.fork_version;
        this.event = data.event;
        this.lp_token_name = data.lp_token_name;
        this.lp_decimals = data.lp_decimals;
        this.lp_ticker_symbol = data.lp_ticker_symbol;
        this.lp_token_address = data.lp_token_address;
        this.lp_token_amount = data.lp_token_amount;
        this.lp_token_price = data.lp_token_price;
        this.exchange_rate = data.exchange_rate;
        this.exchange_rate_usd = data.exchange_rate_usd;
        this.token_name_in = data.token_name_in;
        this.token_decimal_in = data.token_decimal_in;
        this.token_address_in = data.token_address_in;
        this.token_ticker_in = data.token_ticker_in;
        this.token_logo_in = data.token_logo_in;
        this.token_amount_in = data.token_amount_in;
        this.amount_in_usd = data.amount_in_usd;
        this.pretty_amount_in_usd = data.pretty_amount_in_usd;
        this.token_name_out = data.token_name_out;
        this.token_decimals_out = data.token_decimals_out;
        this.token_address_out = data.token_address_out;
        this.token_ticker_out = data.token_ticker_out;
        this.token_logo_out = data.token_logo_out;
        this.token_amount_out = data.token_amount_out;
        this.amount_out_usd = data.amount_out_usd;
        this.pretty_amount_out_usd = data.pretty_amount_out_usd;
        this.borrow_rate_mode = data.borrow_rate_mode;
        this.borrow_rate = data.borrow_rate;
        this.on_behalf_of = data.on_behalf_of;
        this.liquidator = data.liquidator;
        this.user = data.user;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class SafeDetails {
    constructor(data) {
        this.owner_address = data.owner_address;
        this.signature = data.signature;
        this.signature_type = data.signature_type;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class RecentTransactionsResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.current_page = data.current_page;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class PaginationLinks {
    constructor(data) {
        this.prev = data.prev;
        this.next = data.next;
    }
}
class TransactionsBlockPageResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class TransactionsBlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
}
class TransactionsSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TransactionsSummary(itemData)) : null;
    }
}
class GasSummary {
    constructor(data) {
        this.total_sent_count = data.total_sent_count;
        this.total_fees_paid = data.total_fees_paid && data.total_fees_paid !== null ? BigInt(data.total_fees_paid) : null;
        this.total_gas_quote = data.total_gas_quote;
        this.pretty_total_gas_quote = data.pretty_total_gas_quote;
        this.average_gas_quote_per_tx = data.average_gas_quote_per_tx;
        this.pretty_average_gas_quote_per_tx = data.pretty_average_gas_quote_per_tx;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
    }
}
class TransactionsSummary {
    constructor(data) {
        this.total_count = data.total_count;
        this.earliest_transaction = data.earliest_transaction && data.earliest_transaction !== null ? new TransactionSummary(data.earliest_transaction) : null;
        this.latest_transaction = data.latest_transaction && data.latest_transaction !== null ? new TransactionSummary(data.latest_transaction) : null;
        this.gas_summary = data.gas_summary && data.gas_summary !== null ? new GasSummary(data.gas_summary) : null;
    }
}
class TransactionSummary {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.tx_detail_link = data.tx_detail_link;
    }
}
class TransactionsResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.current_page = data.current_page;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
class TransactionsTimeBucketResponse {
    constructor(data, _debug, _apiKey, _threadCount, _urlParams, _enableRetry, _source) {
        this._debug = _debug;
        this._apiKey = _apiKey;
        this._threadCount = _threadCount;
        this._urlParams = _urlParams;
        this._enableRetry = _enableRetry;
        this._source = _source;
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.complete = data.complete;
        this.current_bucket = data.current_bucket;
        this.links = data.links && data.links !== null ? new PaginationLinks(data.links) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Transaction(itemData)) : null;
    }
    async prev() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.prev === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.prev}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.prev}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    async next() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this._apiKey, this._debug);
        const LIMIT = pLimit(this._threadCount);
        while (!success) {
            try {
                let startTime;
                if (this._debug) {
                    startTime = new Date();
                }
                if (this.links.next === null) {
                    success = true;
                    return {
                        data: null,
                        error: true,
                        error_code: 400,
                        error_message: "Invalid URL: URL link cannot be null"
                    };
                }
                const url = `${this.links.next}?${this._urlParams}`;
                response = await LIMIT(() => fetch(`${this.links.next}?${this._urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this._apiKey}`,
                        "X-Requested-With": this._source ? this._source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this._enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await LIMIT(() => backoff.backOff(response ? response.url : url, this._source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this._debug, this._apiKey, this._threadCount, this._urlParams, this._enableRetry, this._source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
/**
 * Transactions APIs
 *
 */
async function* paginateEndpoint(url, apiKey, urlsParams, debug, threadCount, enableRetry, source) {
    let hasNext = true;
    let response;
    let data;
    const backoff = new ExponentialBackoff(apiKey, debug);
    const LIMIT = pLimit(threadCount);
    while (hasNext) {
        try {
            let startTime;
            if (debug) {
                startTime = new Date();
            }
            response = await LIMIT(() => fetch(`${url}?${urlsParams}`, {
                headers: {
                    "Authorization": `Bearer ${apiKey}`,
                    "X-Requested-With": source ? source + " " + "(" + userAgent + ")" : userAgent
                }
            }));
            debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
            if ((enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                try {
                    data = await LIMIT(() => backoff.backOff(response ? response.url : `${url}?${urlsParams}`, this.source));
                }
                catch (error) {
                    hasNext = false;
                    throw new Error(`An error occurred ${response ? response.status : 429}: ${error.message}`);
                }
            }
            else {
                data = await response.json();
            }
            for (const tx of data.data.items) {
                const dataClass = new Transaction(tx);
                yield dataClass;
            }
            backoff.setNumAttempts(1);
            if (!data.error) {
                if ((data.data !== null) && data.data.links.prev === null) {
                    hasNext = false;
                }
                url = data.data !== null ? data.data.links.prev : "";
            }
            else {
                hasNext = false;
            }
        }
        catch (error) {
            hasNext = false;
            if (error.message.includes("An error occurred 429")) {
                throw new Error(error.message);
            }
            throw new Error(`An error occurred ${data ? data.error_code : response ? response.status : "Unknown Error Code"}: ${data ? data.error_message : response && response.status === 500 ? "Internal server error" : "Unknown Error"}`);
        }
    }
}
export class TransactionService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single transaction including its decoded log events. Additionally return semantically decoded information for DEX trades, lending and NFT sales.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} txHash - The transaction hash.
     * @param {GetTransactionQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withDex`: Decoded DEX details including protocol (e.g. Uniswap), event (e.g 'add_liquidity') and tokens involved with historical prices. Additional 0.05 credits charged if data available.
     *   - `withNftSales`: Decoded NFT sales details including marketplace (e.g. Opensea) and cached media links. Additional 0.05 credits charged if data available.
     *   - `withLending`: Decoded lending details including protocol (e.g. Aave), event (e.g. 'deposit') and tokens involved with prices. Additional 0.05 credits charged if data available.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransaction(chainName, txHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withDex !== undefined) {
                    urlParams.append("with-dex", queryParamOpts?.withDex.toString());
                }
                if (queryParamOpts?.withNftSales !== undefined) {
                    urlParams.append("with-nft-sales", queryParamOpts?.withNftSales.toString());
                }
                if (queryParamOpts?.withLending !== undefined) {
                    urlParams.append("with-lending", queryParamOpts?.withLending.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/transaction_v2/${txHash}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/transaction_v2/${txHash}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async *getAllTransactionsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let tx;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                for await (tx of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/`, this.apiKey, urlParams, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield tx;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the most recent transactions involving an address. Frequently seen in wallet applications.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAllTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getAllTransactionsForAddressByPage(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new RecentTransactionsResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {number} blockHeight - The requested block height.
     * @param {GetTransactionsForBlockQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlock(chainName, blockHeight, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block/${blockHeight}/transactions_v3/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block/${blockHeight}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch the earliest and latest transactions, and the transaction count for a wallet. Calculate the age of the wallet and the time it has been idle and quickly gain insights into their engagement with web3.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionSummaryQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `withGas`: Include gas summary details. Additional charge of 1 credit when true. Response times may be impacted for wallets with millions of transactions.
     *
     */
    async getTransactionSummary(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.withGas !== undefined) {
                    urlParams.append("with-gas", queryParamOpts?.withGas.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_summary/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsSummaryResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested page, 0-indexed.
     * @param {GetTransactionsForAddressV3QueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `blockSignedAtAsc`: Sort the transactions in ascending chronological order. By default, it's set to `false` and returns transactions in descending chronological order.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForAddressV3(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.blockSignedAtAsc !== undefined) {
                    urlParams.append("block-signed-at-asc", queryParamOpts?.blockSignedAtAsc.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/page/${page}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transactions_v3/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} timeBucket - The 0-indexed 15-minute time bucket. E.g. 27 Feb 2023 05:23 GMT = 1677475383 (Unix time). 1677475383/900=1863861 timeBucket.
     * @param {GetTimeBucketTransactionsForAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTimeBucketTransactionsForAddress(chainName, walletAddress, timeBucket, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/bulk/transactions/${walletAddress}/${timeBucket}/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/bulk/transactions/${walletAddress}/${timeBucket}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsTimeBucketResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHash - The requested block hash.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetTransactionsForBlockHashByPageQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHashByPage(chainName, blockHash, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockPageResponse(data.data, this.debug, this.apiKey, this.threadCount, urlParams, this.enableRetry, this.source);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch all transactions including their decoded log events in a block and further flag interesting wallets or transactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHash - The requested block hash.
     * @param {GetTransactionsForBlockHashQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `noLogs`: Omit log events.
     *   - `withSafe`: Include safe details.
     *
     */
    async getTransactionsForBlockHash(chainName, blockHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.noLogs !== undefined) {
                    urlParams.append("no-logs", queryParamOpts?.noLogs.toString());
                }
                if (queryParamOpts?.withSafe !== undefined) {
                    urlParams.append("with-safe", queryParamOpts?.withSafe.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_hash/${blockHash}/transactions_v3/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsBlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=TransactionService.js.map