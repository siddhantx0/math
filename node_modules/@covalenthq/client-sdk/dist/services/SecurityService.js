import { userAgent } from "./CovalentClient";
import { debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class ApprovalsResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokensApprovalItem(itemData)) : null;
    }
}
class TokensApprovalItem {
    constructor(data) {
        this.token_address = data.token_address;
        this.token_address_label = data.token_address_label;
        this.ticker_symbol = data.ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_quote = data.balance_quote;
        this.pretty_balance_quote = data.pretty_balance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new TokenSpenderItem(itemData)) : null;
    }
}
class TokenSpenderItem {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.allowance = data.allowance;
        this.allowance_quote = data.allowance_quote;
        this.pretty_allowance_quote = data.pretty_allowance_quote;
        this.value_at_risk = data.value_at_risk;
        this.value_at_risk_quote = data.value_at_risk_quote;
        this.pretty_value_at_risk_quote = data.pretty_value_at_risk_quote;
        this.risk_factor = data.risk_factor;
    }
}
class NftApprovalsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftApprovalsItem(itemData)) : null;
    }
}
class NftApprovalsItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_address_label = data.contract_address_label;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.token_balances = data.token_balances && data.token_balances !== null ? data.token_balances.map((itemData) => new NftApprovalBalance(itemData)) : null;
        this.spenders = data.spenders && data.spenders !== null ? data.spenders.map((itemData) => new NftApprovalSpender(itemData)) : null;
    }
}
class NftApprovalBalance {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_balance = data.token_balance && data.token_balance !== null ? BigInt(data.token_balance) : null;
    }
}
class NftApprovalSpender {
    constructor(data) {
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.spender_address = data.spender_address;
        this.spender_address_label = data.spender_address_label;
        this.token_ids_approved = data.token_ids_approved;
        this.allowance = data.allowance;
    }
}
/**
 * Approvals API
 *
 */
export class SecurityService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to get a list of approvals across all token contracts categorized by spenders for a walletâ€™s assets.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ApprovalsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     
     *
     */
    async getNftApprovals(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/approvals/${walletAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/approvals/${walletAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftApprovalsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=SecurityService.js.map