import { userAgent } from "./CovalentClient";
import { debugOutput, paginateEndpoint } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class BalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BalanceItem(itemData)) : null;
    }
}
class BalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.contract_display_name = data.contract_display_name;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h && data.balance_24h !== null ? BigInt(data.balance_24h) : null;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.quote = data.quote;
        this.quote_24h = data.quote_24h;
        this.pretty_quote = data.pretty_quote;
        this.pretty_quote_24h = data.pretty_quote_24h;
        this.logo_urls = data.logo_urls && data.logo_urls !== null ? new LogoUrls(data.logo_urls) : null;
        this.protocol_metadata = data.protocol_metadata && data.protocol_metadata !== null ? new ProtocolMetadata(data.protocol_metadata) : null;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new BalanceNftData(itemData)) : null;
    }
}
class LogoUrls {
    constructor(data) {
        this.token_logo_url = data.token_logo_url;
        this.protocol_logo_url = data.protocol_logo_url;
        this.chain_logo_url = data.chain_logo_url;
    }
}
class ProtocolMetadata {
    constructor(data) {
        this.protocol_name = data.protocol_name;
    }
}
class BalanceNftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_balance = data.token_balance && data.token_balance !== null ? BigInt(data.token_balance) : null;
        this.token_url = data.token_url;
        this.supports_erc = data.supports_erc;
        this.token_price_wei = data.token_price_wei && data.token_price_wei !== null ? BigInt(data.token_price_wei) : null;
        this.token_quote_rate_eth = data.token_quote_rate_eth;
        this.original_owner = data.original_owner;
        this.owner = data.owner;
        this.owner_address = data.owner_address;
        this.burned = data.burned;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalDataV1(data.external_data) : null;
    }
}
class NftExternalDataV1 {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.owner = data.owner;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute(itemData)) : null;
    }
}
class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
}
class PortfolioResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PortfolioItem(itemData)) : null;
    }
}
class PortfolioItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.holdings = data.holdings && data.holdings !== null ? data.holdings.map((itemData) => new HoldingItem(itemData)) : null;
    }
}
class HoldingItem {
    constructor(data) {
        this.quote_rate = data.quote_rate;
        this.timestamp = data.timestamp && data.timestamp !== null ? parseISO(data.timestamp.toString()) : null;
        this.close = data.close && data.close !== null ? new OhlcItem(data.close) : null;
        this.high = data.high && data.high !== null ? new OhlcItem(data.high) : null;
        this.low = data.low && data.low !== null ? new OhlcItem(data.low) : null;
        this.open = data.open && data.open !== null ? new OhlcItem(data.open) : null;
    }
}
class OhlcItem {
    constructor(data) {
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
    }
}
class Erc20TransfersResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BlockTransactionWithContractTransfers(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class BlockTransactionWithContractTransfers {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.miner_address = data.miner_address;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
        this.transfers = data.transfers && data.transfers !== null ? data.transfers.map((itemData) => new TokenTransferItem(itemData)) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
}
class TokenTransferItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.transfer_type = data.transfer_type;
        this.delta = data.delta && data.delta !== null ? BigInt(data.delta) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.delta_quote = data.delta_quote;
        this.pretty_delta_quote = data.pretty_delta_quote;
        this.balance_quote = data.balance_quote;
        this.method_calls = data.method_calls && data.method_calls !== null ? data.method_calls.map((itemData) => new MethodCallsForTransfers(itemData)) : null;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
    }
}
class MethodCallsForTransfers {
    constructor(data) {
        this.sender_address = data.sender_address;
        this.method = data.method;
    }
}
class TokenHoldersResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenHolder(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenHolder {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.address = data.address;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.block_height = data.block_height;
    }
}
class HistoricalBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HistoricalBalanceItem(itemData)) : null;
    }
}
class HistoricalBalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.block_height = data.block_height;
        this.last_transferred_block_height = data.last_transferred_block_height;
        this.contract_display_name = data.contract_display_name;
        this.last_transferred_at = data.last_transferred_at && data.last_transferred_at !== null ? parseISO(data.last_transferred_at.toString()) : null;
        this.native_token = data.native_token;
        this.type = data.type;
        this.is_spam = data.is_spam;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.protocol_metadata = data.protocol_metadata && data.protocol_metadata !== null ? new ProtocolMetadata(data.protocol_metadata) : null;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new BalanceNftData(itemData)) : null;
    }
}
class TokenBalanceNativeResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NativeBalanceItem(itemData)) : null;
    }
}
class NativeBalanceItem {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.block_height = data.block_height;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote_rate = data.quote_rate;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
    }
}
/**
 * Balances APIs
 *
 */
export class BalanceService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address. Response includes spot prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *
     */
    async getTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render a daily portfolio balance for an address broken down by the token. The timeframe is user-configurable, defaults to 30 days.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalPortfolioForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `days`: The number of days to return data for. Defaults to 30 days.
     *
     */
    async getHistoricalPortfolioForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/portfolio_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/portfolio_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PortfolioResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getErc20TransfersForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.contractAddress !== undefined) {
                    urlParams.append("contract-address", queryParamOpts?.contractAddress.toString());
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/`, this.apiKey, urlParams, BlockTransactionWithContractTransfers, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to render the transfer-in and transfer-out of a token along with historical prices from an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetErc20TransfersForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `contractAddress`: The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `startingBlock`: The block height to start from, defaults to `0`.
     *   - `endingBlock`: The block height to end at, defaults to current block height.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getErc20TransfersForWalletAddressByPage(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.contractAddress !== undefined) {
                    urlParams.append("contract-address", queryParamOpts?.contractAddress.toString());
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/transfers_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new Erc20TransfersResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async *getTokenHoldersV2ForTokenAddress(chainName, tokenAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/`, this.apiKey, urlParams, TokenHolder, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get a list of all the token holders for a specified ERC20 or ERC721 token. Returns historic token holders when block-height is set (defaults to `latest`). Useful for building pie charts of token holders.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenHoldersV2ForTokenAddressQueryParamOpts} queryParamOpts
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `pageSize`: Number of items per page. Note: Currently, only values of `100` and `1000` are supported. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getTokenHoldersV2ForTokenAddressByPage(chainName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/tokens/${tokenAddress}/token_holders_v2/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TokenHoldersResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch the historical native, fungible (ERC20), and non-fungible (ERC721 & ERC1155) tokens held by an address at a given block height or date. Response includes daily prices and other metadata.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetHistoricalTokenBalancesForWalletAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `nft`: If `true`, NFTs will be included in the response.
     *   - `noNftFetch`: If `true`, only NFTs that have been cached will be included in the response. Helpful for faster response times.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *   - `date`: Ending date to define a block range (YYYY-MM-DD). Omitting this parameter defaults to the current date.
     *
     */
    async getHistoricalTokenBalancesForWalletAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.nft !== undefined) {
                    urlParams.append("nft", queryParamOpts?.nft.toString());
                }
                if (queryParamOpts?.noNftFetch !== undefined) {
                    urlParams.append("no-nft-fetch", queryParamOpts?.noNftFetch.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/historical_balances/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/historical_balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HistoricalBalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNativeTokenBalanceQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `blockHeight`: Ending block to define a block range. Omitting this parameter defaults to the latest block height.
     *
     */
    async getNativeTokenBalance(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.blockHeight !== undefined) {
                    urlParams.append("block-height", queryParamOpts?.blockHeight.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_native/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_native/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TokenBalanceNativeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=BalanceService.js.map