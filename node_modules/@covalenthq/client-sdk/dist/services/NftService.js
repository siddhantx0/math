import { userAgent } from "./CovalentClient";
import { debugOutput, paginateEndpoint } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class ChainCollectionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainCollectionItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class ChainCollectionItem {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.is_spam = data.is_spam;
        this.token_total_supply = data.token_total_supply;
        this.cached_metadata_count = data.cached_metadata_count;
        this.cached_asset_count = data.cached_asset_count;
        this.last_scraped_at = data.last_scraped_at && data.last_scraped_at !== null ? parseISO(data.last_scraped_at.toString()) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class NftAddressBalanceNftResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContractBalanceItem(itemData)) : null;
    }
}
class NftTokenContractBalanceItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.floor_price_quote = data.floor_price_quote;
        this.pretty_floor_price_quote = data.pretty_floor_price_quote;
        this.floor_price_native_quote = data.floor_price_native_quote;
        this.nft_data = data.nft_data && data.nft_data !== null ? data.nft_data.map((itemData) => new NftData(itemData)) : null;
    }
}
class NftData {
    constructor(data) {
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.token_url = data.token_url;
        this.original_owner = data.original_owner;
        this.current_owner = data.current_owner;
        this.asset_cached = data.asset_cached;
        this.image_cached = data.image_cached;
        this.external_data = data.external_data && data.external_data !== null ? new NftExternalData(data.external_data) : null;
    }
}
class NftExternalData {
    constructor(data) {
        this.name = data.name;
        this.description = data.description;
        this.asset_url = data.asset_url;
        this.asset_file_extension = data.asset_file_extension;
        this.asset_mime_type = data.asset_mime_type;
        this.asset_size_bytes = data.asset_size_bytes;
        this.image = data.image;
        this.image_256 = data.image_256;
        this.image_512 = data.image_512;
        this.image_1024 = data.image_1024;
        this.animation_url = data.animation_url;
        this.external_url = data.external_url;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftCollectionAttribute(itemData)) : null;
    }
}
class NftCollectionAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.value = data.value;
    }
}
class NftMetadataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTokenContract(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class NftTokenContract {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.is_spam = data.is_spam;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
class NftTransactionsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTransaction(itemData)) : null;
    }
}
class NftTransaction {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.logo_url = data.logo_url;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.is_spam = data.is_spam;
        this.nft_transactions = data.nft_transactions && data.nft_transactions !== null ? data.nft_transactions.map((itemData) => new NftTransactionItem(itemData)) : null;
    }
}
class NftTransactionItem {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_hash = data.tx_hash;
        this.tx_offset = data.tx_offset;
        this.successful = data.successful;
        this.from_address = data.from_address;
        this.from_address_label = data.from_address_label;
        this.to_address = data.to_address;
        this.to_address_label = data.to_address_label;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.log_events = data.log_events && data.log_events !== null ? data.log_events.map((itemData) => new LogEvent(itemData)) : null;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class NftCollectionTraitsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTrait(itemData)) : null;
    }
}
class NftTrait {
    constructor(data) {
        this.name = data.name;
    }
}
class NftCollectionAttributesForTraitResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftSummaryAttribute {
    constructor(data) {
        this.trait_type = data.trait_type;
        this.unique_values = data.unique_values;
        this.values = data.values && data.values !== null ? data.values.map((itemData) => new NftAttribute(itemData)) : null;
    }
}
class NftAttribute {
    constructor(data) {
        this.value = data.value;
        this.count = data.count;
    }
}
class NftCollectionTraitSummaryResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftTraitSummary(itemData)) : null;
    }
}
class NftTraitSummary {
    constructor(data) {
        this.name = data.name;
        this.value_type = data.value_type;
        this.value_numeric = data.value_numeric && data.value_numeric !== null ? new NftTraitNumeric(data.value_numeric) : null;
        this.value_string = data.value_string && data.value_string !== null ? new NftTraitString(data.value_string) : null;
        this.attributes = data.attributes && data.attributes !== null ? data.attributes.map((itemData) => new NftSummaryAttribute(itemData)) : null;
    }
}
class NftTraitNumeric {
    constructor(data) {
        this.min = data.min;
        this.max = data.max;
    }
}
class NftTraitString {
    constructor(data) {
        this.value = data.value;
        this.token_count = data.token_count;
        this.trait_percentage = data.trait_percentage;
    }
}
class NftOwnershipForCollectionResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.collection = data.collection;
        this.is_spam = data.is_spam;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new NftOwnershipForCollectionItem(itemData)) : null;
    }
}
class NftOwnershipForCollectionItem {
    constructor(data) {
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.token_id = data.token_id && data.token_id !== null ? BigInt(data.token_id) : null;
        this.supports_erc = data.supports_erc;
        this.last_transfered_at = data.last_transfered_at && data.last_transfered_at !== null ? parseISO(data.last_transfered_at.toString()) : null;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.balance_24h = data.balance_24h;
        this.type = data.type;
        this.nft_data = data.nft_data && data.nft_data !== null ? new NftData(data.nft_data) : null;
    }
}
class NftMarketSaleCountResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketSaleCountItem(itemData)) : null;
    }
}
class MarketSaleCountItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.sale_count = data.sale_count;
    }
}
class NftMarketVolumeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketVolumeItem(itemData)) : null;
    }
}
class MarketVolumeItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.native_ticker_symbol = data.native_ticker_symbol;
        this.native_name = data.native_name;
        this.volume_quote = data.volume_quote;
        this.volume_native_quote = data.volume_native_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
    }
}
class NftMarketFloorPriceResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.quote_currency = data.quote_currency;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new MarketFloorPriceItem(itemData)) : null;
    }
}
class MarketFloorPriceItem {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.native_ticker_symbol = data.native_ticker_symbol;
        this.native_name = data.native_name;
        this.floor_price_native_quote = data.floor_price_native_quote;
        this.floor_price_quote = data.floor_price_quote;
        this.pretty_floor_price_quote = data.pretty_floor_price_quote;
    }
}
/**
 * NFT APIs
 *
 */
export class NftService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async *getChainCollections(chainName, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/nft/collections/`, this.apiKey, urlParams, ChainCollectionItem, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to fetch the list of NFT collections with downloaded and cached off chain data like token metadata and asset files.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetChainCollectionsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getChainCollectionsByPage(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/collections/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/collections/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render the NFTs (including ERC721 and ERC1155) held by an address.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftsForAddressQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *   - `noNftAssetMetadata`: If `true`, the response shape is limited to a list of collections and token ids, omitting metadata and asset information. Helpful for faster response times and wallets holding a large number of NFTs.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftsForAddress(chainName, walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                if (queryParamOpts?.noNftAssetMetadata !== undefined) {
                    urlParams.append("no-nft-asset-metadata", queryParamOpts?.noNftAssetMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_nft/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/balances_nft/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftAddressBalanceNftResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async *getTokenIdsForContractWithMetadata(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/`, this.apiKey, urlParams, NftTokenContract, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get NFT token IDs with metadata from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTokenIdsForContractWithMetadataQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. If used with "traits-filter", only NFTs matching both filters will be returned. Accepts comma-separated values, is case-sensitive, and requires proper URL encoding.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getTokenIdsForContractWithMetadataByPage(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMetadataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a single NFT metadata by token ID from a collection. Useful for building NFT card displays.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftMetadataForGivenTokenIdForContractQueryParamOpts} queryParamOpts
     *   - `noMetadata`: Omit metadata.
     *   - `withUncached`: By default, this endpoint only works on chains where we've cached the assets and the metadata. When set to `true`, the API will fetch metadata from upstream servers even if it's not cached - the downside being that the upstream server can block or rate limit the call and therefore resulting in time outs or slow response times on the Covalent side.
     *
     */
    async getNftMetadataForGivenTokenIdForContract(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noMetadata !== undefined) {
                    urlParams.append("no-metadata", queryParamOpts?.noMetadata.toString());
                }
                if (queryParamOpts?.withUncached !== undefined) {
                    urlParams.append("with-uncached", queryParamOpts?.withUncached.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${contractAddress}/metadata/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMetadataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all transactions of an NFT token. Useful for building a transaction history table or price chart.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     * @param {GetNftTransactionsForContractTokenIdQueryParamOpts} queryParamOpts
     *   - `noSpam`: If `true`, the suspected spam tokens are removed. Supports `eth-mainnet` and `matic-mainnet`.
     *
     */
    async getNftTransactionsForContractTokenId(chainName, contractAddress, tokenId, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.noSpam !== undefined) {
                    urlParams.append("no-spam", queryParamOpts?.noSpam.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/tokens/${contractAddress}/nft_transactions/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftTransactionsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to fetch and render the traits of a collection as seen in rarity calculators.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getTraitsForCollection(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the count of unique values for traits within an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} trait - The requested trait.
     *
     */
    async getAttributesForTraitInCollection(chainName, collectionContract, trait) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/${trait}/attributes/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits/${trait}/attributes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionAttributesForTraitResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to calculate rarity scores for a collection based on its traits.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getCollectionTraitsSummary(chainName, collectionContract) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits_summary/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft/${collectionContract}/traits_summary/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftCollectionTraitSummaryResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of NFTs (including ERC-721 and ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address.
     * @param {CheckOwnershipInNftQueryParamOpts} queryParamOpts
     *   - `traitsFilter`: Filters NFTs based on a specific trait. If this filter is used, the API will return all NFTs with the specified trait. Must be used with "values-filter", is case-sensitive, and requires proper URL encoding.
     *   - `valuesFilter`: Filters NFTs based on a specific trait value. If this filter is used, the API will return all NFTs with the specified trait value. Must be used with "traits-filter", is case-sensitive, and requires proper URL encoding.
     *
     */
    async checkOwnershipInNft(chainName, walletAddress, collectionContract, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.traitsFilter !== undefined) {
                    urlParams.append("traits-filter", queryParamOpts?.traitsFilter.toString());
                }
                if (queryParamOpts?.valuesFilter !== undefined) {
                    urlParams.append("values-filter", queryParamOpts?.valuesFilter.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to verify ownership of a specific token (ERC-721 or ERC-1155) within a collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} collectionContract - The requested collection address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {string} tokenId - The requested token ID.
     *
     */
    async checkOwnershipInNftForSpecificTokenId(chainName, walletAddress, collectionContract, tokenId) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/collection/${collectionContract}/token/${tokenId}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftOwnershipForCollectionResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build a time-series chart of the sales count of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketSaleCountQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketSaleCount(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/sale_count/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/sale_count/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketSaleCountResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build a time-series chart of the transaction volume of an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketVolumeQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketVolume(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/volume/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/volume/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketVolumeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to render a price floor chart for an NFT collection.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetNftMarketFloorPriceQueryParamOpts} queryParamOpts
     *   - `days`: The number of days to return data for. Request up 365 days. Defaults to 30 days.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getNftMarketFloorPrice(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.days !== undefined) {
                    urlParams.append("days", queryParamOpts?.days.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/floor_price/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/nft_market/${contractAddress}/floor_price/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NftMarketFloorPriceResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=NftService.js.map