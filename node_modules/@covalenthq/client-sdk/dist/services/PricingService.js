import { userAgent } from "./CovalentClient";
import { debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class TokenPricesResponse {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
        this.update_at = data.update_at && data.update_at !== null ? parseISO(data.update_at.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.logo_urls = data.logo_urls && data.logo_urls !== null ? new LogoUrls(data.logo_urls) : null;
        this.prices = data.prices && data.prices !== null ? data.prices.map((itemData) => new Price(itemData)) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Price(itemData)) : null;
    }
}
class LogoUrls {
    constructor(data) {
        this.token_logo_url = data.token_logo_url;
        this.protocol_logo_url = data.protocol_logo_url;
        this.chain_logo_url = data.chain_logo_url;
    }
}
class Price {
    constructor(data) {
        this.date = data.date && data.date !== null ? parseISO(data.date.toString()) : null;
        this.price = data.price;
        this.pretty_price = data.pretty_price;
        this.contract_metadata = data.contract_metadata && data.contract_metadata !== null ? new ContractMetadata(data.contract_metadata) : null;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
/**
 * Pricing APIs
 *
 */
export class Response {
}
export class PricingService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to get historic prices of a token between date ranges. Supports native tokens.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} quoteCurrency - The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     * @param {string} contractAddress - Contract address for the token. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically. Supports multiple contract addresses separated by commas.
     * @param {GetTokenPricesQueryParamOpts} queryParamOpts
     *   - `from`: The start day of the historical price range (YYYY-MM-DD).
     *   - `to`: The end day of the historical price range (YYYY-MM-DD).
     *   - `pricesAtAsc`: Sort the prices in chronological ascending order. By default, it's set to `false` and returns prices in chronological descending order.
     *
     */
    async getTokenPrices(chainName, quoteCurrency, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.from !== undefined) {
                    urlParams.append("from", queryParamOpts?.from.toString());
                }
                if (queryParamOpts?.to !== undefined) {
                    urlParams.append("to", queryParamOpts?.to.toString());
                }
                if (queryParamOpts?.pricesAtAsc !== undefined) {
                    urlParams.append("prices-at-asc", queryParamOpts?.pricesAtAsc.toString());
                }
                const url = `https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/pricing/historical_by_addresses_v2/${chainName}/${quoteCurrency}/${contractAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const res = [];
                data.data.forEach((e) => {
                    const dataClass = new TokenPricesResponse(e);
                    res.push(dataClass);
                });
                success = true;
                return {
                    data: res,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=PricingService.js.map