import { userAgent } from "./CovalentClient";
import { debugOutput, paginateEndpoint } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class BlockResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Block(itemData)) : null;
    }
}
class Block {
    constructor(data) {
        this.block_hash = data.block_hash;
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
        this.block_parent_hash = data.block_parent_hash;
        this.extra_data = data.extra_data;
        this.miner_address = data.miner_address;
        this.mining_cost = data.mining_cost;
        this.gas_used = data.gas_used;
        this.gas_limit = data.gas_limit;
        this.transactions_link = data.transactions_link;
    }
}
class ResolvedAddress {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ResolvedAddressItem(itemData)) : null;
    }
}
class ResolvedAddressItem {
    constructor(data) {
        this.address = data.address;
        this.name = data.name;
    }
}
class BlockHeightsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new BlockHeights(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class BlockHeights {
    constructor(data) {
        this.block_hash = data.block_hash;
        this.signed_at = data.signed_at && data.signed_at !== null ? parseISO(data.signed_at.toString()) : null;
        this.height = data.height;
        this.block_parent_hash = data.block_parent_hash;
        this.extra_data = data.extra_data;
        this.miner_address = data.miner_address;
        this.mining_cost = data.mining_cost;
        this.gas_used = data.gas_used;
        this.gas_limit = data.gas_limit;
        this.transactions_link = data.transactions_link;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class GetLogsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new GetLogsEvent(itemData)) : null;
    }
}
class GetLogsEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.block_hash = data.block_hash;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.supports_erc = data.supports_erc;
        this.sender_logo_url = data.sender_logo_url;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class DecodedItem {
    constructor(data) {
        this.name = data.name;
        this.signature = data.signature;
        this.params = data.params && data.params !== null ? data.params.map((itemData) => new Param(itemData)) : null;
    }
}
class Param {
    constructor(data) {
        this.name = data.name;
        this.type = data.type;
        this.indexed = data.indexed;
        this.decoded = data.decoded;
        this.value = data.value;
    }
}
class LogEventsByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class LogEvent {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.block_height = data.block_height;
        this.tx_offset = data.tx_offset;
        this.log_offset = data.log_offset;
        this.tx_hash = data.tx_hash;
        this.raw_log_topics = data.raw_log_topics;
        this.sender_contract_decimals = data.sender_contract_decimals;
        this.sender_name = data.sender_name;
        this.sender_contract_ticker_symbol = data.sender_contract_ticker_symbol;
        this.sender_address = data.sender_address;
        this.sender_address_label = data.sender_address_label;
        this.sender_logo_url = data.sender_logo_url;
        this.supports_erc = data.supports_erc;
        this.sender_factory_address = data.sender_factory_address;
        this.raw_log_data = data.raw_log_data;
        this.decoded = data.decoded && data.decoded !== null ? new DecodedItem(data.decoded) : null;
    }
}
class LogEventsByTopicHashResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new LogEvent(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class AllChainsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainItem(itemData)) : null;
    }
}
class ChainItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.db_schema_name = data.db_schema_name;
        this.label = data.label;
        this.category_label = data.category_label;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.color_theme = data.color_theme && data.color_theme !== null ? new ColorTheme(data.color_theme) : null;
        this.appchain_of = data.appchain_of && data.appchain_of !== null ? new ChainItem(data.appchain_of) : null;
    }
}
class ColorTheme {
    constructor(data) {
        this.red = data.red;
        this.green = data.green;
        this.blue = data.blue;
        this.alpha = data.alpha;
        this.hex = data.hex;
        this.css_rgb = data.css_rgb;
    }
}
class AllChainsStatusResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainStatusItem(itemData)) : null;
    }
}
class ChainStatusItem {
    constructor(data) {
        this.name = data.name;
        this.chain_id = data.chain_id;
        this.is_testnet = data.is_testnet;
        this.logo_url = data.logo_url;
        this.black_logo_url = data.black_logo_url;
        this.white_logo_url = data.white_logo_url;
        this.is_appchain = data.is_appchain;
        this.synced_block_height = data.synced_block_height;
        this.synced_blocked_signed_at = data.synced_blocked_signed_at && data.synced_blocked_signed_at !== null ? parseISO(data.synced_blocked_signed_at.toString()) : null;
        this.has_data = data.has_data;
    }
}
class ChainActivityResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ChainActivityEvent(itemData)) : null;
    }
}
class ChainActivityEvent extends ChainItem {
    constructor(data) {
        super(data);
        this.last_seen_at = data.last_seen_at && data.last_seen_at !== null ? parseISO(data.last_seen_at.toString()) : null;
    }
}
class GasPricesResponse {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.event_type = data.event_type;
        this.gas_quote_rate = data.gas_quote_rate;
        this.base_fee = data.base_fee && data.base_fee !== null ? BigInt(data.base_fee) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PriceItem(itemData)) : null;
    }
}
class PriceItem {
    constructor(data) {
        this.gas_price = data.gas_price;
        this.gas_spent = data.gas_spent;
        this.gas_quote = data.gas_quote;
        this.total_gas_quote = data.total_gas_quote;
        this.pretty_total_gas_quote = data.pretty_total_gas_quote;
        this.interval = data.interval;
        this.other_fees = data.other_fees && data.other_fees !== null ? new OtherFees(data.other_fees) : null;
    }
}
class OtherFees {
    constructor(data) {
        this.l1_gas_quote = data.l1_gas_quote;
    }
}
/**
 * Class A - Base
 *
 */
export class BaseService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to fetch and render a single block for a block explorer.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} blockHeight - The block height or `latest` for the latest block available.
     *
     */
    async getBlock(chainName, blockHeight) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${blockHeight}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to resolve ENS, RNS and Unstoppable Domains addresses.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The requested address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getResolvedAddress(chainName, walletAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/address/${walletAddress}/resolve_address/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ResolvedAddress(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getBlockHeights(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/`, this.apiKey, urlParams, Block, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the block heights within a particular date range. Useful for rendering a display where you sort blocks by day.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} startDate - The start date in YYYY-MM-DD format.
     * @param {string} endDate - The end date in YYYY-MM-DD format.
     * @param {GetBlockHeightsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getBlockHeightsByPage(chainName, startDate, endDate, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/block_v2/${startDate}/${endDate}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new BlockHeightsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs of the latest block, or for a range of blocks. Includes sender contract metadata as well as decoded logs.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {GetLogsQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `address`: The address of the log events sender contract.
     *   - `topics`: The topic hash(es) to retrieve logs with.
     *   - `blockHash`: The block hash to retrieve logs for.
     *   - `skipDecode`: Omit decoded log events.
     *
     */
    async getLogs(chainName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.address !== undefined) {
                    urlParams.append("address", queryParamOpts?.address.toString());
                }
                if (queryParamOpts?.topics !== undefined) {
                    urlParams.append("topics", queryParamOpts?.topics.toString());
                }
                if (queryParamOpts?.blockHash !== undefined) {
                    urlParams.append("block-hash", queryParamOpts?.blockHash.toString());
                }
                if (queryParamOpts?.skipDecode !== undefined) {
                    urlParams.append("skip-decode", queryParamOpts?.skipDecode.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GetLogsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByAddress(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/`, this.apiKey, urlParams, LogEvent, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all the event logs emitted from a particular contract address. Useful for building dashboards that examine on-chain interactions.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} contractAddress - The requested contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLogEventsByAddressQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByAddressByPage(chainName, contractAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/address/${contractAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new LogEventsByAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async *getLogEventsByTopicHash(chainName, topicHash, queryParamOpts) {
        let success = false;
        let res;
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    throw new Error(`An error occurred 401: ${ApiKeyValidator.INVALID_API_KEY_MESSAGE}`);
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                for await (res of paginateEndpoint(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/`, this.apiKey, urlParams, LogEvent, this.debug, this.threadCount, this.enableRetry, this.source)) {
                    yield res;
                }
                success = true;
            }
            catch (error) {
                success = true;
                throw new Error(error.message);
            }
        }
    }
    /**
     *
     * Commonly used to get all event logs of the same topic hash across all contracts within a particular chain. Useful for cross-sectional analysis of event logs that are emitted on-chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} topicHash - The endpoint will return event logs that contain this topic hash.
     * @param {GetLogEventsByTopicHashQueryParamOpts} queryParamOpts
     *   - `startingBlock`: The first block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `endingBlock`: The last block to retrieve log events with. Accepts decimals, hexadecimals, or the strings `earliest` and `latest`.
     *   - `secondaryTopics`: Additional topic hash(es) to filter on - padded & unpadded address fields are supported. Separate multiple topics with a comma.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getLogEventsByTopicHashByPage(chainName, topicHash, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.startingBlock !== undefined) {
                    urlParams.append("starting-block", queryParamOpts?.startingBlock.toString());
                }
                if (queryParamOpts?.endingBlock !== undefined) {
                    urlParams.append("ending-block", queryParamOpts?.endingBlock.toString());
                }
                if (queryParamOpts?.secondaryTopics !== undefined) {
                    urlParams.append("secondary-topics", queryParamOpts?.secondaryTopics.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/events/topics/${topicHash}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new LogEventsByTopicHashResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal dashboards for all supported chains on Covalent.
     *
     *
     */
    async getAllChains() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                const url = `https://api.covalenthq.com/v1/chains/?${urlParams}`;
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to build internal status dashboards of all supported chains.
     *
     *
     */
    async getAllChainStatus() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/chains/status/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/chains/status/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AllChainsStatusResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to locate chains which an address is active on with a single API call.
     *
     * @param {string} walletAddress - The requested wallet address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetAddressActivityQueryParamOpts} queryParamOpts
     *   - `testnets`: Set to true to include testnets with activity in the response. By default, it's set to `false` and only returns mainnet activity.
     *
     */
    async getAddressActivity(walletAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.testnets !== undefined) {
                    urlParams.append("testnets", queryParamOpts?.testnets.toString());
                }
                const url = `https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/address/${walletAddress}/activity/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new ChainActivityResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} eventType - The desired event type to retrieve gas prices for. Supports `erc20` transfer events, `uniswapv3` swap events and `nativetokens` transfers.
     * @param {GetGasPricesQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getGasPrices(chainName, eventType, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/event/${eventType}/gas_prices/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/event/${eventType}/gas_prices/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new GasPricesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=BaseService.js.map