import { userAgent } from "./CovalentClient";
import { debugOutput } from "../util/ApiHelpers";
import { parseISO } from "date-fns";
import { ExponentialBackoff } from "../util/backoff";
import pLimit from "p-limit";
import { ApiKeyValidator } from "../util/ApiKeyValidator";
class PoolResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new Pool(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class Pool {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
    }
}
class Pagination {
    constructor(data) {
        this.has_more = data.has_more;
        this.page_number = data.page_number;
        this.page_size = data.page_size;
        this.total_count = data.total_count;
    }
}
class Explorer {
    constructor(data) {
        this.label = data.label;
        this.url = data.url;
    }
}
class Token {
    constructor(data) {
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.volume_in_24h = data.volume_in_24h;
        this.volume_out_24h = data.volume_out_24h;
        this.quote_rate = data.quote_rate;
        this.reserve = data.reserve;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.volume_in_7d = data.volume_in_7d;
        this.volume_out_7d = data.volume_out_7d;
    }
}
class PoolToDexResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolToDexItem(itemData)) : null;
    }
}
class SupportedDex {
    constructor(data) {
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.dex_name = data.dex_name;
        this.display_name = data.display_name;
        this.logo_url = data.logo_url;
        this.factory_contract_address = data.factory_contract_address;
        this.router_contract_addresses = data.router_contract_addresses;
        this.swap_fee = data.swap_fee;
    }
}
class PoolToDexItem extends SupportedDex {
    constructor(data) {
        super(data);
        this.logo_url = data.logo_url;
    }
}
class PoolByAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolWithTimeseries {
    constructor(data) {
        this.exchange = data.exchange;
        this.swap_count_24h = data.swap_count_24h;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
        this.quote_rate = data.quote_rate;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.volume_7d_quote = data.volume_7d_quote;
        this.annualized_fee = data.annualized_fee;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.token_0_reserve_quote = data.token_0_reserve_quote;
        this.token_1_reserve_quote = data.token_1_reserve_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new Token(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new Token(data.token_1) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTimeseries(itemData)) : null;
    }
}
class VolumeTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.sum_amount0in = data.sum_amount0in;
        this.sum_amount0out = data.sum_amount0out;
        this.sum_amount1in = data.sum_amount1in;
        this.sum_amount1out = data.sum_amount1out;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.r0_c = data.r0_c;
        this.r1_c = data.r1_c;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
    }
}
class PriceTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.exchange = data.exchange;
        this.price_of_token0_in_token1 = data.price_of_token0_in_token1;
        this.pretty_price_of_token0_in_token1 = data.pretty_price_of_token0_in_token1;
        this.price_of_token0_in_token1_description = data.price_of_token0_in_token1_description;
        this.price_of_token1_in_token0 = data.price_of_token1_in_token0;
        this.pretty_price_of_token1_in_token0 = data.pretty_price_of_token1_in_token0;
        this.price_of_token1_in_token0_description = data.price_of_token1_in_token0_description;
        this.quote_currency = data.quote_currency;
        this.price_of_token0_in_quote_currency = data.price_of_token0_in_quote_currency;
        this.price_of_token1_in_quote_currency = data.price_of_token1_in_quote_currency;
    }
}
class PoolsDexDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.address = data.address;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.quote_currency = data.quote_currency;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolsDexDataItem(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class PoolsDexDataItem {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.exchange = data.exchange;
        this.exchange_ticker_symbol = data.exchange_ticker_symbol;
        this.exchange_logo_url = data.exchange_logo_url;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.volume_24h_quote = data.volume_24h_quote;
        this.volume_7d_quote = data.volume_7d_quote;
        this.fee_24h_quote = data.fee_24h_quote;
        this.quote_rate = data.quote_rate;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.annualized_fee = data.annualized_fee;
        this.pretty_volume_24h_quote = data.pretty_volume_24h_quote;
        this.pretty_volume_7d_quote = data.pretty_volume_7d_quote;
        this.pretty_fee_24h_quote = data.pretty_fee_24h_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolsDexToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolsDexToken(data.token_1) : null;
    }
}
class PoolsDexToken {
    constructor(data) {
        this.reserve = data.reserve;
        this.contract_name = data.contract_name;
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.quote_rate = data.quote_rate;
    }
}
class AddressExchangeBalancesResponse {
    constructor(data) {
        this.address = data.address;
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeBalanceItem(itemData)) : null;
    }
}
class UniswapLikeBalanceItem {
    constructor(data) {
        this.token_0 = data.token_0 && data.token_0 !== null ? new UniswapLikeToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new UniswapLikeToken(data.token_1) : null;
        this.pool_token = data.pool_token && data.pool_token !== null ? new UniswapLikeTokenWithSupply(data.pool_token) : null;
    }
}
class UniswapLikeToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.quote_rate = data.quote_rate;
    }
}
class UniswapLikeTokenWithSupply {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.logo_url = data.logo_url;
        this.balance = data.balance && data.balance !== null ? BigInt(data.balance) : null;
        this.quote = data.quote;
        this.pretty_quote = data.pretty_quote;
        this.quote_rate = data.quote_rate;
        this.total_supply = data.total_supply && data.total_supply !== null ? BigInt(data.total_supply) : null;
    }
}
class NetworkExchangeTokensResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2Volume(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2Volume {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume_24h = data.total_volume_24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.pretty_quote_rate_24h = data.pretty_quote_rate_24h;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_total_volume_24h_quote = data.pretty_total_volume_24h_quote;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
    }
}
class NetworkExchangeTokenViewResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new TokenV2VolumeWithChartData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TokenV2VolumeWithChartData {
    constructor(data) {
        this.chain_name = data.chain_name;
        this.chain_id = data.chain_id;
        this.dex_name = data.dex_name;
        this.contract_address = data.contract_address;
        this.contract_name = data.contract_name;
        this.total_liquidity = data.total_liquidity;
        this.total_volume_24h = data.total_volume_24h;
        this.logo_url = data.logo_url;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_decimals = data.contract_decimals;
        this.swap_count_24h = data.swap_count_24h;
        this.quote_rate = data.quote_rate;
        this.quote_rate_24h = data.quote_rate_24h;
        this.pretty_quote_rate = data.pretty_quote_rate;
        this.pretty_quote_rate_24h = data.pretty_quote_rate_24h;
        this.pretty_total_liquidity_quote = data.pretty_total_liquidity_quote;
        this.pretty_total_volume_24h_quote = data.pretty_total_volume_24h_quote;
        this.total_liquidity_quote = data.total_liquidity_quote;
        this.total_volume_24h_quote = data.total_volume_24h_quote;
        this.transactions_24h = data.transactions_24h;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.volume_timeseries_7d = data.volume_timeseries_7d && data.volume_timeseries_7d !== null ? data.volume_timeseries_7d.map((itemData) => new VolumeTokenTimeseries(itemData)) : null;
        this.volume_timeseries_30d = data.volume_timeseries_30d && data.volume_timeseries_30d !== null ? data.volume_timeseries_30d.map((itemData) => new VolumeTokenTimeseries(itemData)) : null;
        this.liquidity_timeseries_7d = data.liquidity_timeseries_7d && data.liquidity_timeseries_7d !== null ? data.liquidity_timeseries_7d.map((itemData) => new LiquidityTokenTimeseries(itemData)) : null;
        this.liquidity_timeseries_30d = data.liquidity_timeseries_30d && data.liquidity_timeseries_30d !== null ? data.liquidity_timeseries_30d.map((itemData) => new LiquidityTokenTimeseries(itemData)) : null;
        this.price_timeseries_7d = data.price_timeseries_7d && data.price_timeseries_7d !== null ? data.price_timeseries_7d.map((itemData) => new PriceTokenTimeseries(itemData)) : null;
        this.price_timeseries_30d = data.price_timeseries_30d && data.price_timeseries_30d !== null ? data.price_timeseries_30d.map((itemData) => new PriceTokenTimeseries(itemData)) : null;
    }
}
class VolumeTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.total_volume = data.total_volume;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
    }
}
class LiquidityTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.total_liquidity = data.total_liquidity;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
    }
}
class PriceTokenTimeseries {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.quote_rate = data.quote_rate;
        this.pretty_quote_rate = data.pretty_quote_rate;
    }
}
class SupportedDexesResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new SupportedDex(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class SingleNetworkExchangeTokenResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new PoolWithTimeseries(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForAccountAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class ExchangeTransaction {
    constructor(data) {
        this.block_signed_at = data.block_signed_at && data.block_signed_at !== null ? parseISO(data.block_signed_at.toString()) : null;
        this.tx_hash = data.tx_hash;
        this.act = data.act;
        this.address = data.address;
        this.amount_0 = data.amount_0;
        this.amount_1 = data.amount_1;
        this.amount_0_in = data.amount_0_in;
        this.amount_0_out = data.amount_0_out;
        this.amount_1_in = data.amount_1_in;
        this.amount_1_out = data.amount_1_out;
        this.to_address = data.to_address;
        this.from_address = data.from_address;
        this.sender_address = data.sender_address;
        this.total_quote = data.total_quote;
        this.pretty_total_quote = data.pretty_total_quote;
        this.value = data.value && data.value !== null ? BigInt(data.value) : null;
        this.value_quote = data.value_quote;
        this.pretty_value_quote = data.pretty_value_quote;
        this.gas_offered = data.gas_offered;
        this.gas_spent = data.gas_spent;
        this.gas_price = data.gas_price;
        this.fees_paid = data.fees_paid && data.fees_paid !== null ? BigInt(data.fees_paid) : null;
        this.gas_quote = data.gas_quote;
        this.pretty_gas_quote = data.pretty_gas_quote;
        this.gas_quote_rate = data.gas_quote_rate;
        this.quote_currency = data.quote_currency;
        this.token_0_quote_rate = data.token_0_quote_rate;
        this.token_1_quote_rate = data.token_1_quote_rate;
        this.explorers = data.explorers && data.explorers !== null ? data.explorers.map((itemData) => new Explorer(itemData)) : null;
        this.gas_metadata = data.gas_metadata && data.gas_metadata !== null ? new ContractMetadata(data.gas_metadata) : null;
        this.token_0 = data.token_0 && data.token_0 !== null ? new PoolToken(data.token_0) : null;
        this.token_1 = data.token_1 && data.token_1 !== null ? new PoolToken(data.token_1) : null;
    }
}
class ContractMetadata {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class PoolToken {
    constructor(data) {
        this.contract_decimals = data.contract_decimals;
        this.contract_name = data.contract_name;
        this.contract_ticker_symbol = data.contract_ticker_symbol;
        this.contract_address = data.contract_address;
        this.supports_erc = data.supports_erc;
        this.logo_url = data.logo_url;
    }
}
class TransactionsForTokenAddressResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class TransactionsForExchangeResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class NetworkTransactionsResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new ExchangeTransaction(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class EcosystemChartDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new UniswapLikeEcosystemCharts(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class UniswapLikeEcosystemCharts {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.quote_currency = data.quote_currency;
        this.gas_token_price_quote = data.gas_token_price_quote;
        this.total_swaps_24h = data.total_swaps_24h;
        this.total_active_pairs_7d = data.total_active_pairs_7d;
        this.total_fees_24h = data.total_fees_24h;
        this.pretty_gas_token_price_quote = data.pretty_gas_token_price_quote;
        this.pretty_total_fees_24h = data.pretty_total_fees_24h;
        this.volume_chart_7d = data.volume_chart_7d && data.volume_chart_7d !== null ? data.volume_chart_7d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.volume_chart_30d = data.volume_chart_30d && data.volume_chart_30d !== null ? data.volume_chart_30d.map((itemData) => new VolumeEcosystemChart(itemData)) : null;
        this.liquidity_chart_7d = data.liquidity_chart_7d && data.liquidity_chart_7d !== null ? data.liquidity_chart_7d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
        this.liquidity_chart_30d = data.liquidity_chart_30d && data.liquidity_chart_30d !== null ? data.liquidity_chart_30d.map((itemData) => new LiquidityEcosystemChart(itemData)) : null;
    }
}
class VolumeEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.volume_quote = data.volume_quote;
        this.pretty_volume_quote = data.pretty_volume_quote;
        this.swap_count_24 = data.swap_count_24;
    }
}
class LiquidityEcosystemChart {
    constructor(data) {
        this.dex_name = data.dex_name;
        this.chain_id = data.chain_id;
        this.dt = data.dt && data.dt !== null ? parseISO(data.dt.toString()) : null;
        this.quote_currency = data.quote_currency;
        this.liquidity_quote = data.liquidity_quote;
        this.pretty_liquidity_quote = data.pretty_liquidity_quote;
    }
}
class HealthDataResponse {
    constructor(data) {
        this.updated_at = data.updated_at && data.updated_at !== null ? parseISO(data.updated_at.toString()) : null;
        this.chain_id = data.chain_id;
        this.chain_name = data.chain_name;
        this.items = data.items && data.items !== null ? data.items.map((itemData) => new HealthData(itemData)) : null;
        this.pagination = data.pagination && data.pagination !== null ? new Pagination(data.pagination) : null;
    }
}
class HealthData {
    constructor(data) {
        this.synced_block_height = data.synced_block_height;
        this.synced_block_signed_at = data.synced_block_signed_at && data.synced_block_signed_at !== null ? parseISO(data.synced_block_signed_at.toString()) : null;
        this.latest_block_height = data.latest_block_height;
        this.latest_block_signed_at = data.latest_block_signed_at && data.latest_block_signed_at !== null ? parseISO(data.latest_block_signed_at.toString()) : null;
    }
}
/**
 * XYK APIs
 *
 */
export class XykService {
    constructor(apiKey, debug = false, threadCount = 3, is_key_valid, enableRetry = true, source) {
        this.apiKey = apiKey;
        this.debug = debug;
        this.threadCount = threadCount;
        this.is_key_valid = is_key_valid;
        this.enableRetry = enableRetry;
        this.source = source;
        this.LIMIT = pLimit(this.threadCount);
    }
    /**
     *
     * Commonly used to get all the pools of a particular DEX. Supports most common DEXs (Uniswap, SushiSwap, etc), and returns detailed trading data (volume, liquidity, swap counts, fees, LP token prices).
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetPoolsQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getPools(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.date !== undefined) {
                    urlParams.append("date", queryParamOpts?.date.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the corresponding supported DEX given a pool address, along with the swap fees, DEX's logo url, and factory addresses. Useful to identifying the specific DEX to which a pair address is associated.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} poolAddress - The requested pool address.
     *
     */
    async getDexForPoolAddress(chainName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${poolAddress}/dex_name/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolToDexResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get the 7 day and 30 day time-series data (volume, liquidity, price) of a particular liquidity pool in a DEX. Useful for building time-series charts on DEX trading activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *
     */
    async getPoolByAddress(chainName, dexName, poolAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`;
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolByAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and the supported DEX for a token. Useful for building a table of top pairs across all supported DEXes that the token is trading on.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `dexName`: The DEX name eg: `uniswap_v2`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *
     */
    async getPoolsForTokenAddress(chainName, tokenAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.dexName !== undefined) {
                    urlParams.append("dex-name", queryParamOpts?.dexName.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/tokens/address/${tokenAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to return balance of a wallet/contract address on a specific DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address.
     *
     */
    async getAddressExchangeBalances(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/balances/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new AddressExchangeBalancesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all pools and supported DEX for a wallet. Useful for building a personal DEX UI showcasing pairs and supported DEXes associated to the wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} walletAddress - The account address.
     * @param {number} page - The requested 0-indexed page number.
     * @param {GetPoolsForWalletAddressQueryParamOpts} queryParamOpts
     *   - `tokenAddress`: The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `dexName`: The DEX name eg: `uniswap_v2`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *
     */
    async getPoolsForWalletAddress(chainName, walletAddress, page, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.tokenAddress !== undefined) {
                    urlParams.append("token-address", queryParamOpts?.tokenAddress.toString());
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.dexName !== undefined) {
                    urlParams.append("dex-name", queryParamOpts?.dexName.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/address/${walletAddress}/pools/page/${page}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new PoolsDexDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to retrieve all network exchange tokens for a specific DEX. Useful for building a top tokens table by total liquidity within a particular DEX.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetNetworkExchangeTokensQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getNetworkExchangeTokens(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokensResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a detailed view for a single liquidity pool token. Includes time series data.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetLpTokenViewQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *
     */
    async getLpTokenView(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/view/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/view/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkExchangeTokenViewResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the supported DEXs available for the xy=k endpoints, along with the swap fees and factory addresses.
     *
     *
     */
    async getSupportedDEXes() {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/xy=k/supported_dexes/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SupportedDexesResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get historical daily swap count for a single network exchange token.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetSingleNetworkExchangeTokenQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getSingleNetworkExchangeToken(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new SingleNetworkExchangeTokenResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the DEX transactions of a wallet. Useful for building tables of DEX activity segmented by wallet.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} accountAddress - The account address. Passing in an `ENS` or `RNS` resolves automatically.
     *
     */
    async getTransactionsForAccountAddress(chainName, dexName, accountAddress) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/address/${accountAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForAccountAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the transactions of a token within a particular DEX. Useful for getting a per-token view of DEX activity.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} tokenAddress - The token contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionsForTokenAddressQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForTokenAddress(chainName, dexName, tokenAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/tokens/address/${tokenAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForTokenAddressResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used for getting all the transactions of a particular DEX liquidity pool. Useful for building a transactions history table for an individual pool.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {string} poolAddress - The pool contract address. Passing in an `ENS`, `RNS`, `Lens Handle`, or an `Unstoppable Domain` resolves automatically.
     * @param {GetTransactionsForExchangeQueryParamOpts} queryParamOpts
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForExchange(chainName, dexName, poolAddress, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/pools/address/${poolAddress}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new TransactionsForExchangeResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get all the the transactions for a given DEX. Useful for building DEX activity views.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     * @param {GetTransactionsForDexQueryParamOpts} queryParamOpts
     *   - `quoteCurrency`: The currency to convert. Supports `USD`, `CAD`, `EUR`, `SGD`, `INR`, `JPY`, `VND`, `CNY`, `KRW`, `RUB`, `TRY`, `NGN`, `ARS`, `AUD`, `CHF`, and `GBP`.
     *   - `pageSize`: Number of items per page. Omitting this parameter defaults to 100.
     *   - `pageNumber`: 0-indexed page number to begin pagination.
     *
     */
    async getTransactionsForDex(chainName, dexName, queryParamOpts) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                if (queryParamOpts?.quoteCurrency !== undefined) {
                    urlParams.append("quote-currency", queryParamOpts?.quoteCurrency.toString());
                }
                if (queryParamOpts?.pageSize !== undefined) {
                    urlParams.append("page-size", queryParamOpts?.pageSize.toString());
                }
                if (queryParamOpts?.pageNumber !== undefined) {
                    urlParams.append("page-number", queryParamOpts?.pageNumber.toString());
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/transactions/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/transactions/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new NetworkTransactionsResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data.error,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : "401 Authorization Required"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to get a 7d and 30d time-series chart of DEX activity. Includes volume and swap count.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getEcosystemChartData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/ecosystem/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new EcosystemChartDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
    /**
     *
     * Commonly used to ping the health of xy=k endpoints to get the synced block height per chain.
     *
     * @param {string} chainName - The chain name eg: `eth-mainnet`.
     * @param {string} dexName - The DEX name eg: `uniswap_v2`.
     *
     */
    async getHealthData(chainName, dexName) {
        let success = false;
        let data;
        let response;
        const backoff = new ExponentialBackoff(this.apiKey, this.debug);
        while (!success) {
            try {
                const urlParams = new URLSearchParams();
                if (!this.is_key_valid) {
                    return {
                        data: null,
                        error: true,
                        error_code: 401,
                        error_message: ApiKeyValidator.INVALID_API_KEY_MESSAGE
                    };
                }
                const url = `https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`;
                let startTime;
                if (this.debug) {
                    startTime = new Date();
                }
                response = await this.LIMIT(() => fetch(`https://api.covalenthq.com/v1/${chainName}/xy=k/${dexName}/health/?${urlParams}`, {
                    headers: {
                        "Authorization": `Bearer ${this.apiKey}`,
                        "X-Requested-With": this.source ? this.source + " " + "(" + userAgent + ")" : userAgent
                    }
                }));
                debugOutput(response ? response.url : url, response ? response.status : 429, startTime);
                if ((this.enableRetry === true) && (!response || response.status === null || response.status === 429)) {
                    try {
                        data = await this.LIMIT(() => backoff.backOff(response ? response.url : url, this.source));
                    }
                    catch (error) {
                        success = true;
                        return {
                            data: null,
                            error: true,
                            error_code: response.status ?? 429,
                            error_message: error.message
                        };
                    }
                }
                else {
                    data = await response.json();
                }
                const dataClass = new HealthDataResponse(data.data);
                success = true;
                return {
                    data: dataClass,
                    error: data ? data.error : true,
                    error_code: data ? data.error_code : response.status,
                    error_message: data ? data.error_message : response.status === 500 ? "Internal server error" : response.status === 429 ? "429 Timeout Error" : "Unknown Error"
                };
            }
            catch (error) {
                success = true;
                return {
                    data: null,
                    error: true,
                    error_code: error.cause ? error.cause.code : data ? data.error_code : response ? response.status : "Unknown Error Code",
                    error_message: error.cause ? error.cause.message : data ? data.error_message : response && response.status === 500 ? "Internal server error" : !response ? "Unknown Error" : "401 Authorization Required"
                };
            }
        }
    }
}
//# sourceMappingURL=XykService.js.map